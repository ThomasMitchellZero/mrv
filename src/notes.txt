RULE 1:  Coding time is in short supply and this is just a demo. Avoid high-effort solutions to non-central features or problems we don't expect to face.  Easiest to comprehend > fastest processing

RULE 2:  This is practice, and we can only learn by doing.  The more central a feature is to life-like function of the application, the more preferable building the hard-but-right way becomes.




Anything problem I identify with no dependencies is probably getting bypassed.  This is my personal Backlog:
    

    -Figure out a more logical way for Input validation red warning messages to appear when needed.  Right now they are visible at the start and only go away when the user is entering.

    -After entering an item, ItemEntry30 should focus on the itemNum field instead of staying on the Qty field.

    -Product Details <th> in SessionItems70 is actually correctly aligned, but it looks like it isn't.  Figure out a way to either include space or customize margin / padding.

    -Invoice column in in SessionItems70 currently displays nothing.  This is a stupid feature, but figure out a different approach.

    -For the sake of clarity, I really should rename the container for all dispositions into something that reflects that it is a container of all the individual dispositions.

        AFAICT, this term is used in 4 places:
            -Returns
            -ItemEntry30
            -ItemDetails30
            -the matching.js function.

    -Add in Manager Override to be able to cancel restock fee.  As this has no dependencies I'm leaving it for later.

    -I need to figure out how to handle an expired receipt.  It seems like the logic would be pretty heavy and this isn't a very important feature so I am backlogging it.  

        If I had to guess right now, the thing to do would be: 
            -add a date to each invoice in the store.
            -in the matchmaker, sort the array to loop through invoices by date, earliest first.  This is to make sure that if there are any recent invoices that also include the item, those are matched first.
            -For any that are past 90 days, treat as a non-match, add an expired:true property to the specialConditions object, and continue to the next invoice.
            -and then how do I handle the quantities if some aren't matched?

    -Buttons on full pages are not the same size as buttons on 30 panels.  It would be nice if they were.  I have no idea how to make this happen.  

    -At some point I need to make the little indicator that shows number of receipts / unmatched / invoices / etc. at the top left of my components.  The part on SessionItems70 where it shows Receipt List (coming soon)

    -For the MatchMaker - I might need a way of prioritizing Invoices and Dispo types.  Like, for each item, I think we would want to refund the highest-value invoices first.  For dispo types, I think we would want to refund Damaged dispos first.  Right now, both of these are not being processed in any intentional order.  It shouldn't be too hard - I'm already making an array to loop through, so I should just be able to sort those arrays pre-looping.
        -This is going to become a NEED as soon as we start adding in Unwanted dispositions. AFACIT if an unwanted disposition matches first on an item with a Restock fee, customer wouldn't get the full refund?  

    -SessionItems70 and SessionInvoices70 are currently making the choice to render their respective tables or the StartScanning70 panel as conditionals within these components.  These conditions should probably be handled in the dispatching?

    -I need to figure out how to write no-UI functions that can use hooks, especially accessing the app state.  

    -Make sure the prices are realistic in both the product catalog and invoices.

    -On the Item Details page: The quantity needs to be an editable input field.  IIRC I'll have to change how the Items dispatcher is done in Returns.  

    -In the Tenderizer: Right now, all tenderLabels are hard-coded and stored in the Invoice object. Produce a sophisticated String-maker that caluculates the credit card issuer from the ccNum.  So instead of "Credit ****1234" it would say "Discover ****1234". This will also require me to update the credit card numbers in the file, and then delete the hard-coded values.  AFAICT as long as the new function in the Tenderizer stores the new string in the same property name currently storing the hard-coded strings, no further re-wiring should be needed.






//// Github Pages Deployment ////

Writing a little about this since I've struggled with it in the past. This site had a really good walkthrough

https://github.com/gitname/react-gh-pages

I was actually able to skip to Step 7, and I think with what I've done, Step 7 is all I need to do.  I'm going to make a change and see if it appears.

To push it live, I just have to type:     npm run deploy     into the console.



/////////// Recurring Problems ////////////////

If: state on screen appears be one change behind what you've actually done, or actions or payloads or any other unexpected properties are appearing in your state, check the order of the (state, action) arguments in the definition of the reducer function.  Remember, these are ARGUMENTS, so their names are meaningless.  Only their order matters.  



//////////////

24 Sep 2022

    -Explore what I need to do to use heredity in CSS.  Max 1 hour, option to continue if I feel like I am close to the answer.
        -I am not close to an answer.

    -Organize the tables so that inputs <th> and <tr> use a similar structure

    -Make the tables use a flex-basis so I can alter the sizes.

    -Table should be universal.  Lots of other parts of the app use a table, and I want them all to be configurations of this.

        -Some <td> will be components.
        -Some <td> will have multiple elements
        -Need to be able to take unknown number of <td> in each <tr>
        -Incorporate flex-basis into <th>


14 Oct 2022

-Add button to button container, figure out how to control positioning.

-see if React elements can be controlled like HTML elements via CSS.  If not, make alternate plan.
    -It seems they cannot.

-Next test - see if I can add a non-modular CSS class in case I need to control that way?  
    -Also cannot.  I think if I need to, I can pass styles via props.  No idea if this is best or not.  

-Where am I stuck and spinning my wheels?

    - I need the footer container to be able to accept an arbitrary collection of contents.  Could be buttons, could be price summary, could be nothing at all.
    
    With that in mind, I really need to be able to style the Footer contents as well.  I can't know in advance where to align the buttons, how many, etc.  

    - I WANT (but do not need) each base panel to have everything needed: header, contents, and footer.  

    -Conflict:  the <BasePanel> component accepts one set of children, which will fill the content area.  

    -So one way to do it would be to define the footer contents in the section configuration component, and then pass that down via a prop.  AFAICT I can also do any styling in that parent as well.  

    -The other option would be to just make each panel separately.  I guess this is technically violating DRY, but the parts I'm 'repeating' are some pretty simple CSS that I don't think I'm going to mess up.  I think this is the move.  I am also very proud of myself for systematically figuring this out, and I have earned a smoke tonight.  And still 2:30(+?) to go!



-I need to implement the react-router-dom in my file

-I need to convert my nav bar into the HTML <nav> component

-OK, stuck again!  Let's do this!

    Objective - I want the tabs in <GlobalNav> to be able to handle URL requests because I will eventually need this.

    Problem - When I changed the tabs to the <NavLink> compnent from React-Router, the styling got all weird.

    Options:
        -I could fiddle with the CSS in the existing file to see if I can make what I have work.

        -AFAICT the <NavLink> does everything I need OOtB.  I could try to do my mapping to <NavLinks> in the NavBar and do the styling in the NavBar CSS.  

            -Does <Navlink> accept an ID? - YES
            -Does it allow other styling or is it just text?  - I think so?

16 Oct 2022

    -Got the V6.x update working with surprisingly little trouble.  

    -Next is the nav bar. 
        -I need to convert the buttons to <NavLink> components
        -I need to style the NavLink components just like their previous custom peers.
        -I think I can get rid of the custom state tracking.  AFAICT the stock <NavLink> component handles that, and in any case each page will have a different URL.

    -Then I can finally get started on some page building?

    -The Scan Items sidesheet elements are going to need routes as well.

18 Oct 2022

    -The Nav Menu buttons need the ability to have an icon specified on creation.  Options:  

21 Oct 2022

    -Routes:

        -I need to figure out how to do sub-routes - like 
        "localhost:3000/base/branch"
            -I think if I just place the sub-route in the main route, it will work.

        
        -I need to figure out how to do routes that are part of a page: like if I want 70-panel to stay the same but 30-panel to change based on route.

    OK.  I notice I am confused.

    I now have the No Sale button linked to the /nosale route in my code.  When I click the No Sale button, the URL changes to 
    localhost:3000/returns/nosale   which is what I expect.

    However, I set that route to include a page element, that page element does not appear the URL changes.  
        -First.  Do I have any examples of parent routes also rendering elements?  

    -Gonna stop for tonight.  I think that this section haswsxs the answer:  https://www.robinwieruch.de/react-router-nested-routes/


22 Oct 2022
    OK!  Long list of things to work on today!  Wish I were as clear and excited now as I was when I was trying to sleep at 6:00 a.m.  :/

    -First, going to try an experiment of starting with something I know I can crush to get into the groove.  
        -Experiment seems to have gone very well.  I am 100% dialed in and excited to work.

    ROUTING

        -Need to understand <Outlet> and how to use it.
            -May need to re-factor the app to use Outlet with the Nav bar.
        
        -Can I get the whole page to change via a child URL?
            -AFAICT, the answer is no.  I think that you only use a child route if you want to change part of the parent?

        -How do I make part but not all of a page change via URL?

    CONTEXT

        -Do I want the scanned list to be a separate context?  If so, how to reference more than one context?

        -I need to figure out a way to add items to the cart.  This will probably be a form.

    1:30 evaluation:  

        -I THINK I have the answer to my immediate routing questions.  I think what I should do is test to make sure I've got it with the <Outlet> component.  If it is working as expected:
            -Do I diagram one of the Router components?  It would be good to solidify the knowledge, but I haven't gotten a lot of pixels on the screen and that's what I really need to do.

        -I think I should plan to restructure the app based on what I've learned.  
            -I think all flows should have a parent URL - Returns, Exchanges, etc.
            -Some of my components, especially the ones with 30-70 panels, are going to need some Outlet organization.
            -Returns will need to be a parent URL.  

        -For <Outlet> My understanding:  Each parent can have a single outlet.  I can have any number of potential children to fill that outlet, but I can't say "put these children here and those children there" based on URL.  

        -After test and restructure, what to work on next?  Got to keep in mind that I am probably showing this to Kristin on Monday.
            -Scanned Item list?
                -Pros:  
                    -at some point, even in Exchanges, I'm going to have to have entered items.
                    -That is a really cool feature and I don't think it can be matched in Axure.
                -Cons:  
                    -It's not directly related to Returns and it might look like this process is too slow. 

    OK, now 3:30.  At the moment, I do not feel like fiddlefucking around with routing any more.  I want to get some stuff on the screen, and I've got my eye on item entry.  I need:

        -A form that accepts item number
            -looks for a match in product context
            -If found, adds to basket
            -If not found, gives an error.

        -A context scoped to Returns that records all successful item entries... or could it be a state?

        -A table that shows all items in the transaction
            -A component for the the individual LIs.
        
        -the 70 panel should conditionally render either the Scan CTA or the table, depending on if there are any items scanned.

        -First, I think I need a Returns component to track the state.  The contents will change a lot based on what phase of the process the user is in, and I also need to keep track of the state.

    Wrapping it up for the day.  I didn't want to spend the whole afternoon on routing, but... I did, and the stuff I worked on is stuff that I need eventually.  

23 Oct 2022

    -Back to playing with my code Legos!  First task is going to be creating the input form for Item Lookup.

    -Got the base input up and running.  Now I have a decsion to make.  I don't think I need a button component.  I think I could actually do that in CSS, and in the meantime the prop-passing is getting to be a little much.  I think I will do this, but set myself a time limit.  

    -1:45pm Got basically what I want for the input field.  Now I need to get into some data-moving stuff.  I need:  

        Returns:

            -A state in <Returns> that tracks the current Cart.  

            -A table that shows the current items.
                -table must map from an entry in product-context.
                -I'm going to need a custom LI for the scanned-items table.

            -The items must come from the product-context 

            -First, let me just test getting the product-context in Returns.

        product-context:

            -Item keys need to be a product number, not a name.  

    3:30.  Kind of spinning my wheels again.  What NEEDS to happen first is to update the product-context to use numbers as keys.

    Next, I need to figure out how to get a product-context object via its key.

    Then, I can get to work on a <LI> that populates based on that.

24 Oct 2022:

    Things I could do today:


        X -I need a way to show an invalid item entry in the Item Entry form. 

        -Get the Add Item form working.

            -I'm going to do this first because I think making the LI will be easier.  I need:

                - a function in Returns that gets the values of Item Number and Quantity.

                -I need a function that checks 

        -Create the full Item List LI

    Ok, getting some major fucking meltdowns when trying to use the AddItemHandler() function from Returns.  First, potential issues:

        -I know very little about forms and there are a few things I could be doing wrong.

            -Submission behavior is set in the form, not the Submit button.
            -I haven't used preventDefault() anywhere.
            -I'm not referencing an event and the examples I see online appear to do this.
            -I still don't know why I'm using a <form> instead of just some input states.
            -Something else.

        -I've never passed a properties through multiple Outlet contexts.  In theory it should work no different from prop drilling, but I've never done it and I could messing up the technicalities.

        -This whole idea of using routes for nested outlets might be stupid.  I might be better off with fewer URLs and conditional rendering.

            -I guess I should think about this one first, since its implications are the largest and it will cause the most rework if I change my mind.

            KEEP THE URLS

                +The main benefit of URLs is that if I am testing, I can send someone a URL and have them start right at the source.

                    -That's not how the real app works.  Users expect to click through.

                    -The other model I have in my mind is to have one URL per page, and then do all variations through conditional rendering.  If that is the case, I could still direct users to the nearest URL and let them click through from there.
                
                +The URLs are actually kind of nice.  The ability to click and make <thing> be on the page is pretty cool.

                +If this is training then I should be preparing for the worst-case.  When I am navigating websites, the URLs are changing all the time.  I might need that capability.

                    -This is training, but we need output.  It's better to get it working in a non-ideal way and then figure out the rest later.

                + This is what we have now.  We need to make progress.  Major reworks when running into snags is not a good habit to be in.  Figuring out how to make what we have work is what is likely to get us moving again the quickest.

            ---

            1 URL per page
                + This is familiar.  I'm pretty sure I know how to make it work.

                    -It also means we won't be learning as much.

                + It is a simpler conceptual model.  If we get stuck, no one is coming to help us.  The fewer moving parts we don't understand, the easier it will be to find problems.

                + Makes it easier to try that component composition model, which we've also been wanting to understand.

        OK.  Here's my compromise.  I'm going to spend an hour trying to un-fuck what I have.  If I'm still stuck, I will re-evaluate 1 URL per Page, and I plan to use 1UpP for the future work.

            -Test 1:  Pass a function down and run it using a local var as an argument.
                Took a little fiddlefucking but works fine.

            -Test 2:  Check the form examples, look for deviations, address them.

                Well.  I solved it?  I changed the submission to happen from the form, I added a local function with event.preventDefault() and I had that function call the AddItemHandler function from Returns, and now it's working flawlessly.  I do not know why.

25 Oct 2022:

    -Goal for today is to try and get the Product Detail component working.
        -Render the component in the list, populated by a prop.
        
26 Oct 2022:

    -Working on the CSS for the product component.
    -or... maybe not.  Might be the validator.
        -I'm pretty sure I can validate with what I have.  The question is when.

            -I could validate on Submit, which is kind of a lousy experience but would be easy to implement.

            -I could validate inline, but when?
                -De-focus is really nice, but if they do it second then I miss my validation.
                    -I could make item number unavailable until a valid item is entered?  Overkill?

                -I could track in the state, and make the button unavilable until there's a valid number?
                    -but then what triggers the message?
                
                -I think no matter what, I need to check as the text is being entered, and so I need a state to track that.

27 Oct 2022
    -This might be stupid, but I'm trying to re-arrange my input form to use a reducer instead of a state.  I don't actually know why except that reducers are supposedly better for complex states.

28 Oct 2022
    -I got stuck last night, and I think I understand the reason why.  I can make Item Entry work just fine with a reducer.  My problem is that I don't understand why I should be using the reducer instead of a state.  I really can't see any advantages.  It just looks like a different syntax for accomplishing the same thing.

        -I think the very first task of the day should be to get it running again with the Reducer.  After that I can decide how much time to spend on learning.
    1:00

    -Time's kind of getting away from me here.  I just really have not had great luck with Maddie the last few sessions, although I haven't been super great about following procedure, either.

        -I need to choose here:

            1. I could change Returns to use a reducer instead of a state.  
                + If I'm not changing the logic, this -shoudn't- take too much time.
                + Once I figure out the value of Reducer, this is the thing I'm most likely to need to change at the cost of significant re-work.
                
                -The application is working fine right now.  This is more non-progress.

            2. Experiments and reading to find out the purpose of UseReducer().

                + Biggest potential payoff in terms of new understanding.  Right now I don't know why Reducer is better and so I can't design in a way that takes advantage.
                
                - Not immediately needed for anything.

                - Success and progress are ill-defined so not satisfying. Most likely to result in a completely wasted day.

            3. Fix the appearance of the table and its list items.
                + This is the one thing on the list that I KNOW has to be done.
                + It's satisfying and could help get me into the groove.

                - Is likely to need rework if I ever do Item 1.  

        -I think the compromise is to do Item 1, but restrict it to JUST replicating what I'm doing with useState.  No exceptions.  I'm going to make that change, then decide if there's anything I want to modify.  Setting a 45 minute timer to help focus me.

            -One deviation.  I'm going to put all the items in an Items object because eventually I will need to keep track of at least a Receipts object too.  Since I can't imagine not needing this, it's a time-saver to do it now.
    
    3:30:
        -Well, that took way too long, but finally got the Returns state working through Reducer.  

            -The next, obvious question is if I can move more of the state-change logic into the Reducer.
                -It's working, so I don't know if that's the best use of my time.
                -I don't know what the best practices are, so I'm not even sure it's a good use of my time.  

            -I'm gonna take a SHORT break, then devote 20 minutes to Googling to see what I can find on best practices.  If nothing's clear, I'll move on to more visible work.

            -OK.  From the examples I've seen, the Reducer function TENDS to be pretty simple - 

            -The plot thickens.  It is true that I am not using Redux, but IIRC most of the useReducer() approach was developed from Redux.  Redux recommends that as much logic as possible be placed into the Reducer.  

                -This was just a comment from StackOverflow, but it made so much sense to me.  Paraphrasing:  determine whether or not to dispatch in the action creator, but do all other logic in the reducer.

            -Is it stupid to refactor the Returns logic into the Reducer?  Probably.  Am I going to do it anyway?  Also probably.

                -Well, that was completely painless.  Took one try and ten minutes.  :/
        
    Going to do some work on the styling next.  

        -A little sidetracked again.  I found a way to make the scrolling happen but it had a really weird effect where it was making the whole table grow outside the bounds of the flex box.

            -I am actually wondering if it's not happening at the level of the <tr>

30 Oct 2022
    OK, gotta get in and beat this boss.

        Approaches:

            -The CSS for the table is all over the place.  Who coded this shit?
            I need to decide if I am going to have global CSS for the table, or if I am going to keep it with the component?

                -I don't know of any other tables I plan to make, but I could be wrong.  If I do make another table, I could always override that with local CSS, but that's kind of inelegant.  I like the idea of having one style per chart, so I think that's what I'm going to do.

            -I THINK it's some part of the table, and specifically its size, that is causing the overflow.  Everything was fine until the table got big.

            -So first move is going to be refactoring the table's style.  

    OK.  Why am I stuck?
    
        -First problem was that the table's height was behaving unpredictably.  

        -Second problem is that the horizontal layout appears to be behaving strangely and I don't know why.

        -Now I am wondering if I should even be using tables at all.  

        -I've rolled back all changes so I can think clearly about this.

            -ReactTable might be better.  It seems to be very well liked.  I don't know what the benefits are, but if I keep working on the stock table I might find myself stuck.

            -IF my normal table can:

                -fit within the confines of the page
                -scroll
                -let me set columns, or at least respond to different content sizes

            Then the stock table is fine.  

        -I think I am going to try with react-table.  My main reason is that it has a sorting feature, which would be nice not to have to build.

        https://react-table-v7.tanstack.com/docs/quick-start


1 Nov 2022

    -I got the react-table working from the example.  However, at least right now it looks pretty overwhelming to me.  Like, there's a lot of stuff in the code that I just don't understand what it is or why it is there.

        -Let's just dig in a little bit here.  I would hate to give up so close to the end.

            -First.  That scary object at the start was just object de-structuring.  I added in an additional variable that I got from the TableInstance object and it printed as expected.

            -Second.  You can populate from a nested object.  I tried it with the sample data and it worked as expected: "parent.child"  so that isn't my problem.

    -My main concern is that I am depending on something I didn't build and don't understand, so if I get stuck I don't have a great way of fixing it.

2 Nov 2022

    -I finally got use-table working. Right now, I don't see it.  It literally looks exactly like what I had before.  The main draw feature is that it is supposedly easy to sort the columns, but I'm not planning to do that any time soon.  
    
    -If I come back to this, the keys I need to remember are that memoizing the data arrays and the names of the props/object thingy(?) passed to the useTable() function turned out to be very important.

    const tableInstance = useTable({ columns, data });

    I think I'm just going to roll with the stock table and try to figure out why it wasn't working.  

        -Was this a mistake?  I think so.  The best defense I can make is that this package appears to be more capable and if I could have made it work with little effort, it might have been worth it.

        -The best criticism I can make is that even from the start, I didn't see a way that this would solve my immediate problem: scrolling and LIs not fitting on screen.  As soon as it became apparent that this was going to be a lot of extra complexity, I should have abandoned it.

        I need  to be very suspicious of the 'IDK, I just want to' feeling.

    -So, on to the table.

        -I don't understand why my table was such a disaster, and there are so many interactions that I think I'll have trouble finding the problem.  I think the right move is to start with the 70 panel, and build the chart up from scratch.

    -Before I get into that, I think I need to make an architecture decision or else I'll need to do more fiddling.

        I want the /returns URL to be an entry point.  The 70 and 30 panels should be handled by conditional rendering.  From /retuns you can navigate to deeper URLs, but until you choose a path the page should just be conditional rendering.

            -The first thing I will need to change is that I need the 30 panel to be able to do conditional rendering.
            
                -To do that, I will need to track the active state.  Maybe with a reducer?

                -If they don't already do this, I need the button component to accept different onClick() functions.  Sometimes it's going to be a state+conditional render change, other times it will be a URL change.

                -OK, I got it.  Figured out how to do navigation via a function.  This was the site that solved it for me:

                https://www.kindacode.com/article/programmatically-navigate-using-react-router/

3 Nov 2022

    -Next little question: should I control the Returns Index 70 and 30 panels with one or two reducers?  
        - as far as I know, they are completely independent, so there's no reason to pair them.  

        - It's not that much harder to make it all one reducer, and if I'm wrong I could see just wanting one.

    -The question now is: do I have a skinny Reducer and let the lower-level components set the state via payload, or do I try to get as much of that logic in the Reducer as possible?
        -I feel like the answer is the skinny reducer.  I think that gives me maximum flexibility to determine what is getting rendered.  
            

4 Nov 2022

    -Having slept on  it, I think the right approach to the cart is to conditionally render the Invoice and Items tables based on the session.  If there is anything in the table, we render the table.  If not, we render the Scan screen.

    -OK, got it working.  The next thing to to is to start hacking away at the table.  I think the approach is just going to be: build a very long table, styling as I go, and see where the problem is.


5 Nov 2022

    -Things to try - 
        -convert <tbody> to flex

        -App.js class main container seems to be the right height for the blue area, but is somehow flexing beyond that.  Why?

        -if absolutely nothing else is working, try clearing out most of .App and putting the table as close as possible to the top of the tree.  This will at least allow me to try out different approaches without having to change 15 different layers of children.
    
        -I know exactly why I'm avoiding getting started.  I'm pretty sure making the table into <flex> won't work and then I'm back to frustration.  But there's no alternative.  I am blocked.  However long this problem takes to solve, I can't proceed until it is.  

            -OK.  I made the simple version.  It works exactly like I want :/  But I guess that means I can find the mistake somewhere in here?

            -Added in the horizontal container, which I really expected was goign to be the source of all the problems.  Again, working perfectly as expected.

            -Another clue.  AFAICT, the faulty offset is exactly the height of the nav bar.  Something is not counting that in the percentage.

            -Also.  When I take out the nav bar, the size is porportioned correctly.  WTF?

        -Holy shitballs.  I got it.  I'm actually not sure what was tripping me up.  It was some combination of three things.  
            -First, for a flex item:    height: 100%   is relative to the PARENT, so if I have other items with defined sizes in there eating up space, I could get overflow.  The correct way to do it is:
                flex: 1 1 0rem.

            -The second thing, the reason why I didn't see changes earlier, is that    flex: 1 1 0    is not actually a valid input.  The third argument needs to include a unit, like rem or %.  Otherwise, I think it just compiles to 'auto' which would explain why I was seeing no response - it was just being its default self.

            -Finally.  Not sure if I grasped this or not, but the   flex:   property determines how this element behaves RELATIVE TO ITS PARENT.  I was trying to make the table a flex-item and getting weird shit, but that's wrong.  It is a flex item already.  All children of a flex box are flex items, whether they themselves flex or not, and I can use any flex-item properties on them.

    -Next up is to get the custom table working.  I'm going to try my existing custom table and see if it works.

        -Custom table is working, accepting data from Returns context, and adding and deleting properly.  Next step will be to wire the Product Detail section together, but that should be pretty easy.

        -If you told me this morning that this is what I'd have at the end of the day, I'd take that outcome in an instant.  :)

6 Nov 2022
    -First thing.  I've been wondering if I should plan the invoice/item matching.
        -At some point it will be needed, but that's fairly far in the future.  
        -The only dependency right now is mapping the item object to the table.  
            -I could just plow ahead.  It's some re-mapping, but I'm not concerned at all.
            -I could come up with a plan, re-do the data map, and then figure out the acutal mapping later.

    -I think I am going to devote an hour to the problem.  After that, I'm gonna stop or I could be on this all day.

        OK.  I think I can fix the item part for now.  What I have is an array of items that looks like:

          {
        productData: {
          img: toilet_img,
          price: 8.75,
          itemNum: "400",
          modelNum: "RT3301",
          description: "American Standard Grand Duke II with Ultra-Flush",
          categories: ["Stock", "Special Order"],
        },
        scanDetails: {
          quantity: "1",
          scanID: 511415,
        },
      },


    {
        img: toilet_img,
        price: - -
        itemNum: "400",
        modelNum: "RT3301",
        description: "American Standard Grand Duke II with Ultra-Flush",
        categories: ["Stock", "Special Order"],
        quantity: 1,
    }

    or:

        "400": {
            img: toilet_img,
            price: - -
            itemNum: "400",
            modelNum: "RT3301",
            description: "American Standard Grand Duke II with Ultra-Flush",
            categories: ["Stock", "Special Order"],
            quantity: 1,
    }

    I think having it as an object will make some of the matching easier, but I need to do a bit of extra work to make it into an array for rendering.

    I think if I'm going to do this, my plan should be to ONLY keep the object in the state.  The only time I convert it to an array is right before I need to render something.  The object is always the SSoT.

    Right now, I will need to change:
        X-the SSoT state in Returns
            -to be an object instead of an array.
        X-the function that adds a new entry in Returns
            -to add an object instead of an array.
            -to check if this item already exists.
        -the Returns function that removes an item.
            -Remove by key instead of filtering?
        X-the Returns function that checks for a match?
        X-the Add Items window?
        -The table that renders all scanned items to convert the array into 

17 Nov 2022

    I'm back!  Been a while since I wrote, but I was actually figuring out how to do matching with wireframes in Figma.  Time not wasted.

    My next move is to turn all that thinking into action.
        - I am going to need to make sure I have a structure for everything.

            -Items
            -Invoices
            -Unmatched
            -MatchEligble
            -Matched

            and in context:
            -InvoiceCatalog
            -ProductCatalog
    
    -Wait.  I actually do get to start with something easy!  I need an invoice entry.  

    -OK, next up.  For an invoice to be added, it needs to pass 2 checks.   
        -that it is in the context.
        -that it hasn't already been used.
    
        -Maybe what I need to do is change the context checker to check both.  I'm sure that would be a better user experience because it gives the user the tools to resolve it.

-19 Nov, 2022

    -I'm also going to try something new here.  Like programming mindfulness.  When I find myself not typing, I should either start writing code or come to this file and start writing to get unstuck.  Like, no self-shaming, just gently return the focus to the work.

    -Today's engine-starter.  I'm going to make the text that describes the error states for Enter Invoice.

    -Next, I need to add each new added invoice to the list.

    -I think after that, I will get into the three derived states.

    -12:20.  No mystery here.  I know exactly why I am stuck.  I would LIKE to have  ALL state-setting logic inside the reducer function.  Then I wouldn't have to export any state-setting functions.  I could just export the reducer function and control everything that happens with action.type.

        -Benefits:
            + A lot fewer functions to export and track down.  I'll know what the function is setting state and what level it is occuring at, assumign I name things well.  
            + Complexity Creep is has the potential to be a huge problem for me, since I'm the one that has to solve every problem.
            + I -THINK- that's actually cleaner code, and if I want this to be a demo piece that is important.
            + If I don't do it now and change my mind later, this gets a lot harder.

        -Risks:
            -I don't know if this approach will work.  I haven't really seen it done, and that should give me pause.

            -I really need to be making progress.  It's been a long time and I still haven't progresses beyond the Index URL for returns.

            -One of the things Harrison got into trouble with for Solo was that he was constantly tearing up old track because he figured out a new, better way to do things.

        Moving the statement inside the component function seems to work fine.  Now, what does that get me?

            -In the reducer, I can now call other functions that exist inside the component function, like checking if an item in the Product Catelog.  

            -I don't think I can directly call a second function that changes the state.  I think once the Switch statement returns, the state updates, the component re-renders, and we're back to zero.

                -How to do sequential updates, like validations?

                -Not sure useEffect is appropriate for this.  The documentation seems to suggest that this shouldn't really be used for state-setting.

                -I guess I could do all my updating at once.  Like, if I've got an input change, I could get that in the payload, do the validation, and then assign both the new input and the new validity status in the State object.

            -I think some functions, like checks to see if something is in the catalog, would have to be passed down.  Or could they live within their respective contexts?

            -Still not sure what the answer is, but I am definitely engaged and interested now :)

            -Maybe the thing to do would be to try it with Invoices, and then see how it extends.

            -I think I'm gonna try it.  New objective:
                -Session state should be updatable using just the Reducer function.
                -Anything not changing the session should be defined at the lowest possible level that covers all children.
                    -What about validation functions?  Could I do validation in the component?
                    -I could.  I can.
            
        5:00 - slowly chugging along, but I haven't gotten majorly stuck yet.  I think the next thing I need to do is populate the Invoices table, because the next thing after that is being able to delete invoices.

        Alternatively, I could try and move / clean up via reducer the Items table, but that thing is working OK right now and I think I'm gonna pass.  I think the time for that will be when it comes time to populate the derived lists.

22 Nov 2022
    Making decent progress on completing the move to dispatching.  
        For adding an item, here's what needs to happen.
            -Get item number + quantity from the ItemEntry30 component
            -If itemNum does not exist in sessionItems, add it.
            -update quantity.

    -Next, I want to make three sample objects, one each for Unmatched, MatchEligible, and Matched.

    -OK, so now.  How to handle this updating?  

    -Raw list > derived list > matched list.  I suppose I could:
        -have a function that generates each derived list
        -have a function that generates the matched list
        -Whenever Items or Invoices is updated, I call those two functions, then update the state with all three.  
        -I guess my only reservation is that I'm doing a LOT of work in the reducer, but I don't know any reason why that wouldn't be OK.

        -Alternatively, I could have separate functions to update EACH state object, but I think then I'm back to having to pass named functions back down the chain.

        If I do this:  one of my lists won't be in the state yet.  Either the soon-to-be Unmatched or MatchEligible will be a variable that hasn't been added to state yet.  Will this work?

            -the only purpose of UM and ME is so that I'm not double-counting either items or receipted items.
            
            -I DO NOT need to maintain UM and ME.  In fact, I definitely don't want to.  
                -I need to conceptually grasp that these two are re-generated with every state change.  

            -I do at least need to keep the Unmatched list, or else I can't give store credit.
            -I think I also need to end up with the Matched list in the state, since 

    Fuuuuuuuuck.  I think I might have just screwed myself.  I don't know if I can call outside functions in the reducers.  

        -Remember.  This is an ASSUMPTION.  We've gotten into trouble like this before.  Let's check this assumption before we blow everything up.  At the very least, I don't know WHY it wouldn't work.

        -OK.  I have not fucked myself.  I am really glad I checked my assumptions because otherwise I would have had to redo a shitload of work.  Good on me for learning from past mistakes.  I'm calling it a day.

23 Nov, 2022
    Having a little trouble getting engaged with the work, but what else is new?

    -One thing giving me pause right now.  Do I want to generate a Match-Eligible list, or do I want to to the matching directly from the invoice list?
        -IF I match directly from the invoice list, I will be left with three neat little buckets:
            -A revised invoice list, with all the returned contents subtracted.
            -An unmatched list, which will get store credit
            -A matched list, which will be refunded in kind.  
        
        The last two, I will have already.  The first  item, the revised Invoice list, I could then push directly to the existing invoice list.

            -So basically, this is a question of whether I want to update the invoice list or not.

            Argument in favor:
                + I can probably do it.  Searching for matches is going to be harder, and sorting prices highest to lowest is going to be MUCH harder, but I think I could do it.

                + If I ever do want this feature in the future, I will have to do a lot of uprooting to get it.

                    -Or will I?  I'm not consuming the invoices that aren't matched anywhere, so I think the only code affected would be the matching function.  

                + If I am every showing code in a portfolio review, I might get asked why I don't have this.  "It was too much work" might be a difficult answer.  

                I think I need to get moving on this.  Pushing unmatched back into the store is deep into "Nice to have"

                I'm good with back-burnering it for now.

    For the time being, I'm going to move the function into a separate file.  I'm really just testing the JS code and this makes it a lot easier to debug in the terminal.  

        -Having spent some time with it, I'm really, seriously considering the option to just look for matches in the invoice list directly.  The path TO the items sold is a little longer, but I really don't think it's all that much harder.

        -Do I want to account for the possiblity of more than one price for the same item on an invoice?
            -on the one hand, no.  On the other hand, it's not that much more code?  

24 Nov 2022

    I need to do a little thinking here.  
        -AFAICT, I should NEVER reference anything from the two loop arrays other than keys.  
        -I should never be modifying anything other than the three derived objects - Unmatched Items, Modified Invoices, and Matched.
        -AFAICT, I should only be referencing these as well?


    Well, kind of hard to believe but I've finally got it working.  At least on my sample data, it handled a variety of scenarios.  I think I've been working on this damn thing for at least 2 weeks.  
    
    -I'm gonna try leaving this one as a module and importing it into Returns.  I think it will be a little easier to debug if it's a standalone file?  

    -I'm losing velocity here and I know exactly why it's happening.  I'm afraid that if something goes wrong in the Returns context I will have no way to fix it.  I'm riding a high from my progress and I'm afraid of the crash.  Litany of Gendlin.  I might as well find out.

    -So.  It is KIND of working, but I am getting some weird behavior.  It *LOOKS* like I am somehow modifying the session items and invoices, which should never happen.  

        -I notice I am confused.  What is happening that I do not expect?

            -First, the sessionInvoices state is being modified, which should never happen.  Even more frustrating, session Items are not modified if they are a lower quantity but they are if they are higher?

            -Third, if I enter an item quantity lower than the qty on the invoice, that item and the corresponding quantity appear in Matched.  The item appears to be finding a match.

            -Finally, if the item quantity is higher than the invoice qty, no matched item appears in Matched object, but the unmatched Item is reduced by the correct amount.

        -I don't know what is going on, but the first problem seems the most significant.  No matter what, I need to figure out why that is happening because matchmaking should NEVER alter session states.

        -I'm gonna call it a night.  I'm actually feeling pretty good.  This is a puzzle, but I'm pretty confident the matchmaker is working fine and that was by FAR the most uncertain part.

26 Nov 2022
    -Back in the saddle after Thanksgiving.  NGL, I'm expecting today to be hard.  I know that I am especially vulnerable to time-wasters when I'm not sure how to procreed.  I can't get success-feeling from good sources so I give into my hunger for stimulation from crap.  
    
    -Today can be a good test of meta problem-solving skills.  This really is a unique opportunity to see if I can make good decisions without knowing the answers.  I want to get good results, but all I can control for certain is making good decisions.  

    -The good news is that I HOPE this will be the last hard thing I have to do for a while.  

    -How to attack this problem?

        -I could attack the problem with a bunch of console.log()  It's crude and offers a pretty limited view of what is happening inside the app, but I know I can make it work.

        -I could look more into how to debug React applications.  IF there is a really good way to do this, I think it would be my ideal.  It was so helpful when I was making the matchMaker() module to be able to step through the code line by line, make predictions, and see all the variables changing.  

            Risks:
            -I don't actually know if this will help anything.  I could just come up empty and have nothing to show for the time.

            -I don't actually have a clear picture in my mind of why my current de-bugging tools are unsatisfactory.  

        -I could re-structure the app.  I actually have no idea if having lots of logic in the Dispatcher is good practice.  

            -Like, I could make a case that what I am doing is clear because I've got one action type per input.  User adds an item => do every step involved in adding an item.  

            But I don't know if that's right.  Maybe having one top-level function per action, and once dispatch action per state-change is more logical?

            -This seems like the most risky option.  It is DEFINITELY a lot of work, and without knowing where the problem is coming from, I don't actually know if this solves it.  

            -It also feels like giving up in a way I don't like.  It isn't actually identifying the problem.  It's just throwing away a lot of code and hoping that the problem was contained in what I got rid of.  Worth a try if I am TRULY stuck, but this ought to be a last resort.

    -Here's what I'm going to do.  I'm going to allow myself 30 minutes to do Googling on how to debug React apps.  Highest potential payout, and if I whiff I'm not out a lot of time.  If it looks promising I can extend, but if not I will then move onto console.log()

    -Web searching has indicated that eitehr IDE or Chrome dev tools are common approaches to debugging, although console.log() works too.  I think the case for the dev tool debuggers looks stronger because the people who prefer it generally described why, while the console.loggers didn't really elaborate.

    -Next question is - debug in Chrome, or in the IDE?  


    -OK, so one issue identified in Chrome:  I am passing through a LOT of React framework code that I didn't write and don't especially care about.  This might have been the reason I gave up on this in the past.

        -My working hypothesis is that at least at macro scale, I shouldn't be stepping though line by line - I should be using F8 to jump to the next breakpoint and then crawl line by line if I need to.

    -Current working understanding:
        F8 - either pauses or resumes operation.  I think this proceeds to the next stopping point?  Generally, this jumps me to the next breakpoint?
        F10 - goes to the next function within this particular scope, or up one scope level if it is the last?
        F11 - most specific, step by step ahead?

    -By clicking the appropriate JS filename in the Call Stack tree, I can switch scopes.  This is really helpful because I previously didn't know how to see values outside of the current block.

    2:00 - Made no progress on the problem, but I feel good about the decisions I've made so far.  I've engaged with the work.  

    OK, I think I've identified where at least one problem is occurring.  After I've evaluated the larger of the two qtys, AFAICT that is when the bad change happens.

        -Somehow, when I change the Invoice quantity, I'm changing the actual invoice, not the thing I thought was a copy.  Even nuttier, the change is happening in the Context, too.  How is that even possible?
    
    -According to what I've found, I should not be mutating state in the reducer function.  Why?  No idea.  
        -Am I mutating state?  

    -This article has some clues:  https://dev.to/il3ven/common-error-accidentally-mutating-state-in-react-4ndg#:~:text=In%20simple%20terms%20it%20means,Here%20are%20two%20examples.

    -Assuming I comprehend correctly, this is telling me 2 important things.

        -First, consider: 
            const newState = oldState;
            newState += 1;

            According to this, modifying the newState will actually modify the old state.  It's definitely possible that I'm doing that somewhere.

        -Second, using the Spread operator should prevent this:

            const newState = {...oldState}.  Now, my new state should be a separate copy.

        -OK.  I have an idea.  I wonder if this is all happening because I am not spreading the Invoice Content into a new object.  If I am modifying the context, that might explain why the Invoice state is changing.  It pulls the details from the context, so if I make a change upstream then I might pull in the bad change later.  It would also explain why I'm getting less weird behavior from items, because although I made the same mistake, I'm not changing any values that are stored in the Item context.  Let me at least give it a shot.

            -Didn't work.  Still having the same error.

    4:45: did some Googling and took a walk and I think I have at least a partial answer.  

        const Alpha = {
            val1: 20
            val2: {
                a: 30;
                b: 40;
            }
        }

        const Beta = Alpha;

        Beta is not a copy of Alpha.  Beta is just a pointer to Alpha.  If I make a change to Beta, that change appears in Alpha, too.  If instead I try:

        const Beta = {...Alpha}

        I can change the value of val1 and val2 in Beta without affecting Alpha.  But if I change the values in   Beta.val2.a   those changes will actually appear in Alpha.  Level 1 and level 2 are now separate, but Level 3 is still pointing back to the original.

        This makes sense.  It explains why, despite all my redundant top-level spreading, I'm still modifying the quantity in the product-context store.  Unless I spread absolutely every level, I'm still pointing at the original value.

        That also explains why some of the guides I found encourage us to make states as flat as possible.

        So.  What to do.  

        -I could manually spread everything, but that seems like a huge pain in the dick.  Or is it?  I really just need to spread the Invoices, and I think I just have to do it once?

        -Related: I could try and flatten the invoices, but it could get kind of fucky with the products, since I never know in advance how many there are.
        
        -There is a workaround, which seems to involve converting the object to JSON and then parsing that JSON.  That apparently works because I've seen it suggested in a few spots.  It does seem kind of hacky and apparently doesn't work with methods or circular references.  Right now I don't THINK I have either, so this is the lowest-impact way to move forward.  

        -I'm sure I could find some kind of 3rd-party library that does deep copies.  Lodash CloneDeep appears to be pretty popular.

    That brings me to my second question, whether I should have multiple reducers (called 'slices'), each controlling one property of the state.  I like the idea, but it seems like I would have to do a lot of learning to make it work.  

        -OK.  It's almost 6:00 and I'm losing steam here.  I think what I am going to do is try to get the deepClone working and then call it a day.

        OK.  It's working.  I tried some tests and didn't find any unexpected result.  I think it is actually working.  Let's call it a day.

27 Nov 2022
    Sunday Fun Day!  A couple things I need to be able to do.  I need to:
        X-When a product LI is clicked, console.log its details
        -Create a side panel that displays product details when given a product number.
        X-figure out why TF my icons keep shrinking.
        -Add buttons that allow me to track disposition.
        -Store disposition in state
        -Validate disposition requirements.
        X-Get rid of Vertical Nav component.  It's not doing anything.
    
    For the side panel:  I think I need to change the ReturnsIndex file to accept two additional payload properties.  

    a little stuck.  Right now, the dispatch function of the ReturnsIndex container only accepts which panel to switch to.  It does not accept details.

    I think I could just have a payload.contents property in my state.  I actually don't think I need to maintain it at all.  I just need to get it up so I can pass it back down to the item details page.  

    2:45 - panel navigation is now working correctly. 

    3:25 - I was feeling a little disinterest before my break, but I'm feeling pretty good right now.  Engaged and ready to get back to it.

    4:15 - I no longer feel good.  I'm feeling high effort gravity and a low comprehension radius.  Gonna finish this session and call it a day.

28 Nov 2022

    Next, I think I need to add the disposition state.
        -There are 7 possible damaged dispositions plus one Didn't Want / Need.  
        -The sum of all dispositions cannot exceed the number of entered items.  
        -DW/DN can be calculated last, since it is just the total number minus sum of all DD dispositions.

        -When D/D is selected, there should be a default active state.  Either the first one in the list, or the last one selected.  

        -Selecting any disposition should display its current quantity in the input field.  Changing the input field should change both.

    
3 Dec 2022

    -Back to the real work! I need to remember that the 4 (and even the 20) are not time limits.  I think that for this, some extra writing could really save me some work. !coding !== !working.  Today I would really like to get Item Disposition done.  A few things I know I need:

        X -Disposition is going to live with the scanned items, so I know I need a way to store it there.  I also need a dispatch action to handle it.
            -Should the disposition include ALL categories, or just the ones that have a value?  
            -I think I'm going to have it track all values.  That will make the code a little cleaner.

        -How to incorporate disposition into the matching?  I don't know, but this only really affects the return price so it's not super urgent.  Another thing to keep in mind - AFAICT, I really only need to track the total quantity and the Defective quantity.  If I really want to shortcut the process, I could just track those.

        -The real action is going to be in the disposition 30 panel itself.

            In the 30 panel state, I need to store:
                -Which tab is active
                -If Defective, which disposition is active.
                -I need to track a dispoObj, since that part of the payload is what will be used to update the session Item disposition.  
                
                

            -I need a way to read the stored disposition from the Session items state.  
            - I need a way to get the sum of all item dispositions, and that sum cannot exceed the total item quantity.
            -Whenever a Defective disposition is selected, I need to:
                -read its current quantity from the Session Items Disposition object.
                -Display that quantity in the Sessions Disposition object.
                -Check that this dispo quantity + all others does not exceed scanned quantity for this item.
                -Update the item.disposition[whatever] property.
    
    -12:20 - not doing super great on time.  I'm definitely distracted by that Spinnaker Bradner watch I just found, plus the fact that Mom is waiting on me to make a Christmas request.

        -I think the thing to do next is to handle the Tabs and whichever Defective button is selected in the ItemDetails page.  I know I'm going to need that and it doesn't require me to make any hard decisions right now :)

    2:00 - I am kind of hitting a wall here and I suspect it's because I haven't been eating.  I think the actual most productive thing I could do is take a few minutes, slam some food, and take a SHORT walk.

    2:30 - back at it.  First little task will be to populate the dispo buttons and make them activate with a click.

        -Now, potentially the hardest task.
            - the thing I want to do is pull the quantity directly out of the session Item state, and have the input update it directly.  The reason I want to do this is because AFAICT I don't actually have a button to submit this form, and I think that would be frustrating to have to remember to submit or else your item is lost.   Can it be done?

        -If I can get it working, a QoL addition I want to add is to have the test reflect the qty scanned.  But that is later.

        -I might also move the Quantity input into the Condition Picker?  It's not like it can be interacted with elsewhere?

    5:55 - I have actually accomplished what I set out to do today.  I'm not sure how it happened except I kept doing the next thing and suddenly the problem was gone.  I'm also very proud of myself for identifying the fact that I was replacing the state with just the item and disposition.  I feel like I could go for another three hours, which experience has taught me means that I'm about 40 minutes from being sick of coding :P

    I also learned a new pattern.  You can real-time update an outside state just as easily as a state within the component.  No theoretical reason why it shouldn't work, I guess, but I'll be a lot more comfortable in the future because I know it works.  When I'm taking my walk and thinking about how to be a better coder, I should think about why this correct answer wasn't my initial thought.

    Maybe it's the Adderall but I'm legit feeling amazing right now.  I would have accepted partial progress as a good day, and I actually solved the whole thing.  Now I just need to decide which QoL improvements are my highest priority.  Options are:

        -Figure out the quantity validation.  This should probably be the choice as it is the only one that is actually necessary for the project to function right.

        -Show quantities on all the disposition buttons.  Might be worth putton off because it's not necessary but would be a GREAT get-into-flow starter for tomorrow.  Might need useEffect because I don't want appearance changing as the user is typing.  This will be the trickiest part for sure.

        -Figure out how to use refs.  There are a number of inputs that I would really like to autofocus given various conditions, but again, nice-to-have.

        -The buttons do need CSS, but it's tempting to leave it out since it doesn't affect anything else.  Necessary, but no dependencies.

        -I actually do still have a frog to eat, and that's figuring out where to put the input field.  I could definitely leave it.  I actually probably should leave it, because it reflects the app as it currently exists.  

        -I should also change the input so it's inactive when the Unwanted tab is selected.  Right now, any input there changes the current Reason quantity, which is not what I want.  Also, Didn't Want should never be adjustable.  It's just what's left over.

        -At some point I do need to go through ItemDetail30 and make sure it's well-commented.

    Gonna do the quantity validation.  It's the logical choice.  First, I think this validation can live in the Item Details component.

        -I will need to loop through the disposition array and get the sum.  But when?  Maybe prior to input?  I think I can set a max value to the input field, and that would be nice to know.

        -The other question is a UX question. 
            -First, how do I handle a situation where the user inputs a quantity larger than the undisposed quantity?  If I just set a max they can't screw it up, but there's no indication why they can't enter the number they want to.

            Also, I think I need to use the max?  The state is being updated as they type, so if they exceed the max, I can't have them just going ahead with that value in the input field.

            Finally, how do I show the number of undisposed items?  If you don't know that, you don't know the max you can enter.

        -Almost right on cue, I am sick of coding.  For tomorrow:  I want to start on some standardized text styles.  I think I will apply them to this work and MAYBE add them retroactively.
    
-4 Dec 2022

    Today might be a struggle.  I slept like absolute shit last night because I lost control of my mind and couldn't stop thinking about that Haikyuu point-buy-team building game.  I also need to not think about the game today.  It sounds funny to say that I have to avoid fantasy football like heroin and I do play it for laughs, but like, I legit lost control.  "Just a little more, I'm sure this next idea will crack the problem"  I genuinely wish I'd never found it.

    OK, on to the work.

    First things first.  I'm going to make a list of some important pages, check them for common text styles, and try to create a CSS file to capture the important ones.  This will not be fun, but I'm redoing a LOT of work with these damn text styles and I would really like to stop it.  This will not be fun, but if I don't do this now it's going to be re-work later and this task MUST be done at some point.  At the end of 20, I would like to have a list on the way.

        Just wrapped up the 20, and I think I have the list.  Honestly doesn't look as bad as I expected (although that's partially because I haven't built as much UI as I hoped.)

        Next thing to do is see if I can find some guidelines about how to name things, like what tags to use and such.

        -Looks like it's just <p>, <h*>, and possibly label.  

        -I think the next thing to do is to create some default elements in a CSS text style file and get after it from there.  I'll do one more 20-minute run and then start a longer one for the reassignment.

        -OK. Gotta go through the files and look for text fuckery. This task is going to suck, but I just need to dive in and make it happen.  One way out!

        -related to nothing, but I also need to remember that part of the reason the UI hasn't moved in a month is because I also had to solve the flexbox / table scrolling problem.  That involved a lot of knowledge-building and rework.  

    3:15 - back after it.  I'm proud of myself.  I kept my short break short, and I'm still feeling pretty good.

        -I'm gonna get the 3 completed 30-panels done, and then dig into the disposition setter.

        -Ok, all the cleanup is done.  I'm back at the starting line.  

    4:15 -Starting to feel a little loss of steam.  I'm gonna go until I'm not having fun but I already consider today a win.  Those app-wide styles were something that needed to happen.

    5:00 calling it a day.  Gonna take a walk and think about what to do next.  I can either add in validation or consider what would come next.

5 Dec 2022:  69-420 for work.  I'm planning to make sure my Figma screens for the SOS restocking fee are correct, then I will find an appropriate location and post them.  I need to confirm with Kristin that we can ask our outstanding questions in tomorrow's Returns team meetings.

At some point today I need to message my doctor and get the ball rolling on next steps for my knee.

The first coding thing I should do is box up the process for Github Pages,

I think if I really blaze, I could complete my work tasks in the 20 section :)



-7 Dec 2022.  
    Well, for some reason, I seem to have lost my styling changes in the Item Details section.  I'm not sure how, because they were present in the working protoype I showed Liz.  And also some but not all of my styling in RefundTotal?  And my notes from 7 Dec.
    
    I was at least able to roll back and address whatever the problem was with the ItemDetails.

    Next, I need to figure out what's wrong with the RefundTotal.

    Remember to change Returns reducer to make sure it re-evaluates if the disposition changes.

10 Dec, 2022

    69-420:  I think the DispoMatcher is actually in pretty good shape.  I got about halfway through it on Thursday and it was mostly doing what I expected.  The 'Watch' section in VS Code is really nice, and I need to find its equivalent in Chrome.  (Update:  the feature exists in Chrome.  I haven't used it yet, but the terminology is the same)

    I also feel slow, dumb, and heavy, so worried about today's outcome.

    -Get the matching module to account for dispositions.

    -Add a check to the Dispositions to make sure that total dispositions are always equal to items entered.
    
    -Figure out how to handle the Unwanted items.  I either recompute every time or else I need to store total items entered separately.  

    -Make sure that changes to dispositions are triggering the Matching process.  IIRC matching only happens when an item is added.
        -A side note to this process.  I might want to ditch having a separate Action for changing dispositions, and just handle it as an 'ADD_ITEM'

    -I think I'm going to start with the Quantity / Dispositions question.  It's not a HUGE change, but it will affect how I do the matching so I might as well do it first.

        -Right now, I'm kind of thinking I should track total quantity separately.  I need it for:
            -the display table.
            -I need to have a total to calculate Unwanted, since it's always the remainder.  If I don't store it, I have to re-derive it.
            -I need to store a total to calculate the upper limit.
            -In the MatchMaker, it would simplify the check if there are any items remaining.  

        -Looks pretty clear right now that I should store the total.

        -Next question is how to store Unwanted.  Options are:  

            -A method that, by hand, names all of the properties EXCEPT Unwanted and sets Unwanted to total - (result of the method)
                -This is pretty reliable but kind of crude?

            -Copy the object, delete Unwanted, sum all remaining, set that to index?

            -Put Unwanted in some notable position, like first.  Make object into array, delete first term FROM ARRAY, then assign Unwanted to that sum?

            -I was going to say that Unwanted is calculated only once, but I guess that isn't true.  It's also calculated when an object is created.  

            -The reason I am stalling is because I don't know how the object I plan to create will behave.  I suppose the correct thing to do would be make a test object and check on that.

    1:00.  If there is any easy way to set a property's value from within the function, I haven't found it.  What to do?

                -I don't technically have to set the value of Unwanted within the object.  I could create the empty Disposition object and then set the value of Unwanted from outside.  

                -It's also not a requirement to have Unwanted within the object, but it makes the Matching logic more complicated.  

            -Let me back up a step.  In the ItemEntry component, right now I am currently just adding a quantity.  I suppose that either here or in the actual ADD_Item action, I could just automatically add that quantity to Unwanted.  
                -but what does that solve?  
                -I guess that IF I want all changes to an item to be handled in the same action, I need some clean way of turning an item with one disposition into an item with another.
                -the reason that is good is because if all dispositioning is happening in the same place, I could do the Unwanted calculation there.

            -I also really could handle it in the Matching system.  Whenever matching is called for, I can just calculate Unwanted there.  
                -My feeling is 'I don't like it'.  Feels dirty somehow.  It feels like I should always have the state as complete as possible.  However, I don't really have a better answer and this gets me moving.  
                
                I suppose I could justify it by saying that 'Unwanted' isn't a real quantity.  It's not being used anywhere before the match.  
                It's not a duct-tape workaround of my limited knowledge of objects, it's a clever solution to simplify the logic of the Matchmaker :P

            -Also, potential problem:  what happens when I add new items to items that already have dispositions?  NVM, past-me already handled it :)  Preparation is a gift to your future self :)

    -3:15  You are stalling.  You don't know what problems you'll encounter and you're afraid you won't be able to figure out a solution.  Don't be scared.  We've got the debugger.  This is so much easier than how we used to debug.  Get in there and press that green arrow.

11 Dec 2022 - 
    69-420.  The past two weeks have taught me that the name is important.  Every time I'm tempted to skip, my inner 14-year-old says "yeah, but...hehe...69-420...heh..."
        The VERY first step is to get in there, cycle through the Matchmaker, and find out where it's all going wrong.  I feel like we're close.  I would not be surprised if I had enough time to get to something else this afternoon.

        -The next next step is going to be to look at the Disposition inputs.  It's very important that the total dispositions do not exceed the quantity entered.  
            -I think the way to do it is to use the Quantity as a maximum value.  The logic for how to handle a larger input is still TBD, but I've at least got the component set up to show an error messsage.
        -The last little feature would be to make the buttons show show the total number entered.  this is acutally not a great solution, but I'll have to live with it.
        

        -A small little morsel:  the Item Quantity input should have a minimum value of 1.  Nobody should be entering 0 or negative numbers.

    2:30.  OK.  Decision time.  Right now, the Matchmaker appears to be working, but it isn't 'squeezing the air' out of the disposition objects.  Right now, if I match all of the items in all invoices before going through all of an item's dispositions, there are going to be some dispositions with a value of zero.  I don't know what the downstream effects (if any) are goign to be, but it feels sloppy.  Options  are:

        +Do nothing.  I'm spending time and focus on something I don't even know will be an issue.
            -This feels sloppy.  In my mental style guide, each step in the process should do as much refining as is practical so as to not create problems down the road.
                +If we're doing the next option, this is fine.  In fact, this is fastest.

        +Change the input so that I don't put in empty dispositions in the first place.  If we're REALLY sticking to the aforementioned style guide, THIS is where that pre-fining should actually be happening.
            -This will happen at some point, but I just want to get this damn module working and if there's a problem I now have to chase it through three components and not 2.
            -I'm PRETTY sure I can do pre-finement in the Product Details section, but not 100%.

        +Squeeze in the module.  I think the place to put it is right at the top.  I have to loop through each dispo object anyways because I'm summing their values to get Unwanted.  I could add in a quick condition that deletes any properties with a value of zero.  That will save me quite a few loops AND it ensures that the squeezing happens even if there are NO invoices that have the product.
            -This is spending time on a feature we hope won't be in the final version.
                +Just do it and add a big old comment to take it out once the pre-finement is set up.  And maybe a note in the running To Do list so I don't forget.

    I'm gonna go for Option 3 and do the squeezing in the module.

    4:05:  Fuuuuuuuuck.  Edit: NVM, not fuck.  If the disposition quantity is greater than the invoice quantity, the program WILL loop and check the next dispo, but after that fails it will try to match dispositions from the top in the next invoice, and it will start with the disposition that wasn't fully matched previously.  That was scary.  I thought I was gonna have to do some deep rebuilding.

    4:55 - OK.  I put the new module into the app and tried a few things.  I still need to figure out how it is that I am going to call the Matchmaker when disposition changes, BUT!  The matchmaker is working!  I admittedly didn't put it completely through the ringer, but it did appear to be making its matches correctly!  Excellent!

17 Dec 2022
    I've been sick the last few days, hence the lack of progress.  But I'm feeling good enough to get back after it!  Now, the eternal question - what to do today?

    -One thing I think needs an answer is a plan for dealing with the Scanned Items state.  Options:

        -Have one reducer for all additions.  In every case, payloads to this reducer carry everything they need to re-assemble the new Item object and then replace the existing session item.  And remember, payloads are only coming from two places - Add Item or Item Disposition.

            -I think I'm kind of leaning this way right now.  I had this idea that separating the two would be a lighter operation because it was only updating the disposition, but that's not actually true.  In both cases, I have to clone and replace the entire item state.  

            -It's also a much simpler conceptual model.  In fact, I might even change the name to EDIT_ITEMS because that's what I'm actually doing.  

        -OK.  We've got a direction.  The next thing to do is figure out how to handle the incoming dispositions.  My cases are:
            -A new item is added:  Add a new, empty set of dispositions.
            -An existing item is added: The dispositions are whatever that item already had.

            -The other thing I should keep in mind.  I'm currently envisioning having a whole empty Dispo object that I squeeze later, but it would be cleaner to ONLY have dispositions for items with a value.
            Maybe the correct approach is to do it with the whole empty item for now?  I can already do squeezing in the Matchmaker so it's not like this will be a problem.

            -All incoming items have a Disposition payload.  If the payload is empty, use the existing payload.  Else, use the payload coming in.  
                -I have to remember that there will never be two payloads with values being added together.  Any payload with numbers will be coming from Item Details, in which case I am just cloning the existing dispositions, changing them, and sending them back.


            All items from the Add Item 30 panel will come in with an empty disposition.
                -That's not quite right because 

            -mind bouncing around a lot right now but at least I am not bored!\

            -If the incoming item has a disposition, use that disposition.  Otherwise, use the existing dispostion.  If there is no disposition, create the empty one.  

            This will work.  I just have this feeling there's a simpler logical approach.

            -If the payload contains a disposition, that is the new disposition.  Otherwise the disposition is the old disposition.

            OR - {... oldDispo, ...newDispo} ? I think if you call the spread operator on undefined, you just get an empty object?

        I did some tests and it works.  You can spread undefined into an object and it will just return an empty object.  OK.  So I think that's the new logic.

        More decisions.  I tried making a new Disposition Input with a fake name, and it actually did update the Returns state with the fake name and value, although I'm getting some 'Controlled State' errors.  (NVM, solved by providing a default value of 0)

        Here's what I think.  I guess we could do the squeezing here, but I don't see any problem doing it in the Matchmaker.  I still have to have the squeezing because even if I start with an empty Disposition object (i.e. NOT a full disposition object with all values set to 0), I can still have disposition categories with values of 0 - if I fill the field and then delete it.

        I think this might be time for a branch, since I think I understand this all but I could run into a disaster.

        OK.  Time to stop and reflect.  I think I now have the ADD_ITEM function working correctly.  I also learned some REALLY useful new tools:

        The first is the Nullish Coalescing Operator (  ??  ) It's similar to the || operator, but the Or operator returns the second term if the first term is ANY falsy value, while   ??  returns 2nd term ONLY if the first term is null or undefined.  If it's falsy, that gets returned.

            false || 13   -- returns 13
            false && 13   -- returns false

        The second thing I learned is about the TypeError.  I think I've unknowingly been running into this a lot.  TypeError occurs when you try to do an operation on an element that can't support it.

        const one = undefined
        one.two = abc

        I won't be able to read either of these because the program with throw a TypeError before I can even get to the end of my declarations.  the [ . ] operator means "the following property out of the proceeding object.  Well, undefined isn't an object!  There's no property to get,and so JS won't let me try to define it, even if it might become an object later.

        that brings me to the third thing I just learned, the Optional Chaining operator (  ?.  )  This checks if the preceeding term is defined before evaluating its following property.  So from the previous example, if I write
            const three = one?.two
        then   three   will be undefined instead of giving me an error.

        This could really clean up my code because I have SO MANY 'Do you even exist' checks before doing things.  Wow.  No matter what else happens, these three learnings have already made today a win :)

    4:50 - I'm now successfully updating the dispositions via ADD_ITEM.  I've now run into another problem.  No matter what defective reason I have selected, entries in the input field are just updating the default reason.  The defectiveReason state does change when I switch the tabs.  

    OK.  Sweet.  It's now working just like I wanted.  Maybe time to test some matching?

    Looks like we've got another problem.  My Unmatched invoices aren't totaling up correctly.  
        -When I add the first disposition, everything's fine.  Unmatched shows that disposition and quantity, and then whatever's left is recorded as Unwanted.
        -When I add a second disposition, it appears correctly along with the first, but Unwanted is now gone.
        -Adding additional dispostions also works as expected, but Unwanted still doesn't show up.

    My very first thought is to do the Unwanted check in the ADD_ITEM case.  I don't feel great about it because I haven't actually identified the problem, but I guess I should try it and see if it works.  I'm not hacking, just gathering a data point.

    It's still not working, but I have a hunch I know where it is and so I've got a good place to pick back up.

    Ha. Well, I changed the ItemDetails30 to make pass back integers and not strings and now it's working perfectly?

    Well, not perfectly.  Deleting an invoice isn't working, but that REALLY is a problem for tomorrow.

18 Dec 2022

    OK.  Did a little more work last night while the pizza was cooking and it appears that invoice deletion is working correctly.  I'm not 100% sure but it really does look like the Matching is working correctly.  

    Next two tasks on the menu.  First, I need to make it so that the total qty of dispositions does not exceed the qty of items scanned.  

    I also need to figure how how to handle the deletion of the item currently being shown in Item Details.  Ideal behavior would be that if the item is deleted, the 30 panel would then navigate to the Item Entry screen.  
        -Ha.  I legit expected to struggle with this one, maybe even taking the rest of the day, but it's done.  

    11:40 - I'm about an hour in and I feel really good.  I don't quite understand it because I slept like shit last night but I feel engaged and smart right now :)

    OK, I've been kind of fiddlefucking around with getting the display state to show empty instead of zero and not dispatch any falsy values but that's really not blocking any progress.  It's just not as clean as I would like.

    What I need to do is figure out the sum evaluation.  
        -After fiddling with the HTML max property, it appears that it doesn't actually restrict the user from entering the value.  So I could have a total of 20 items, and I'm actually not restricted from putting 21+ in the input field.  In a way this is good because it makes my decision for me.  I will have a check on the input field, and if it's out of range I will show an error message and not dispatch.  I think.

        I really do not like that there isn't a form submit button.  I can't really check and make sure everything is tight before I send it.  The problem is that each input is representing 2 things that aren't necessarily the same.  They're representing the user's input, and also the value in the system.  

        I wonder if I could separate them.  Like, every time the page is refreshed, I get the existing disposition object.  Whenever there is a change, I check the validity.  If everything is valid, I dispatch the update.  If it isn't, I do not.  So far, so good.  That lets me do everything I want.  

        Here's the one issue I see.  If the user inputs a bad value, they don't necessarily know they haven't changed the value in the system.  And if they navigate to any conditions that have values, those other conditions are going to show errors, too.  

        I also need to be careful not to over-solve this problem.  At this time, I've already departed from the live app, since that doesn't let you enter more than one disposition.  I hate this input style because I don't think it represents the business logic, so any work I put into this current version is work I am hoping to throw out later.  

        OK, absolute minimum:
            -Conditional dispatching.
            -Show an error if conditions are exceeded.
            -I need to create an invalid input field CSS style

    1:20  Definitely losing speed here.  I'm gonna make a quick mail run.  Maybe that will clear my head.   

    2:30 - Not exactly the break I was hoping for, but I'm back after it.  I think I'm gonna do one more session and then call it a day.  Let's re-evaluate.
        -I've got the sum-checker working (I think)  I need to figure out WHEN to check the sum, and my responses to the potential outcomes.
            -I think once an input is made, we check that input's value against the unassigned quantity.
            -If the unassigned quantity is smaller, we run our Error procedure.  We DO NOT dispatch, although since the values are linked I don't actually know what happens to the contents of the input field.
            -If the value is legit, we dispatch and proceed as normal.

        -OPTIONAL:  Prior to dispatch, I could also squeeze the upcoming dispositions object.
            -DOUBLE-OPTIONAL:  That would potentially allow me to go through and have 

    5:40.  Going to stop for the day.  Haven't tested hard but the ItemDetails disposition setting appears to be working.  It's adding to the total and not dispatching any input values that would push it over the total.  

    However, the inputs are behaving weird.  Like if I'm near the limit and I try to enter 12, it will accept the 1 but won't let me add the second character.

    For next time:  I think what I need to do is get the item dispostions from the session state.  I need to then CLONE that object in a local state, and do modifications to the local state.  Whenever the local state becomes valid, I dispatch to the session.  Until then, it stays local.  

    That's a pretty cool model.  I should probably remember that for other things.

    6:45.  My dispatches to the Returns Session object are one step behind the local state and I don't currently have the brainpower to figure this out.

    For tomorrow - try putting the dispatch to Returns outside of the onChange loop.  

20 Dec, 2022
    69-420 I know EXACTLY why I don't want to start today :)  I don't truly understand the relationship between state and re-rendering, which means I don't actually know why my app isn't working, and I don't truly understand the de-bugger, which is why I fear the frustration of it behaving unpredictably.

    That said, this does need to be solved, and if I can't do it the way I have in mind, I have plenty of dirtier alternatives.  IMO first move should be to do a littl reading about state and rendering and see what I can find.

        -OK, from the documentation:

        1. The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call.

        2. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldnt affect your code.

        3. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.

    That...was not a waste at all.  That was actually really helpful.  I've learned a few things.  First, AFAICT it's OK for me to be batching multiple state updates together (#3).  I thought that was my problem but it looks like I was wrong.

    Second, AFAICT, the state variable doesn't actually change when it is dispatched.  Like, the dispatch will happen, but if there's any code after the dispatch, that code will run before the re-render.  I think that's why my global state was one step behind my local state.  I was updating the global state with the local state's value, and because state updates are batched, the local state didn't yet reflect the new values.  

    I think if I dispatch to the global state with the same dispos object variable I used for the local state it should work?  

    OK.  Working correctly now, but a slight snag.  For multi-digit characters,each subsequent digit is dispatched separately.  If I enter a multi digit number where the first digit is under the limit but the second digit is over, the first number gets dispatched and the second does not.  Options:

        -It's not the end of the world.  Going over will show the user an error and directions to correct it.  Remember, we want to get rid of this whole input pattern soon.  Don't fix something that's getting discarded anways.

            -My main objection to this is that it's doing something the user wouldn't expect, and it is happening out of sight.  If I'm typing 12 and the second digit makes it invalid, I do not expect that the first digit has already been applied.  

            -OK, here's another crazy thought.  What if: on every change to the input field, I evaluate the input contents.  On every content change, I dispatch contents to local state.  If qty is valid, I dispatch it to global state.  If not, I dispatch null?  

            Right now I think that's the least bad solution?  I think it's at least more in line with expected behavior.  If my input is wrong I wouldn't necessarily expect it to be dispatched.

                Here's the snag.  If I switch to any other input while I'm over the limit, that is also going to be wrong, and it's also going to be dispatched as 0.

                -What if.  On every Damaged button click, the local state dispos object gets set to the value of its global counterpart?  Like, as soon as the user clicks away from any field, the local dispos get reset?  Quantities only get submitted if they are valid, so every other quantity other than the one they just entered will be as it was.  



        -What I REALLY want is for the local state to handle all the state changes, and wait a while to dispatch to the global state if the local state is valid.  Basically, I want Submit without the Submit button.

            -I could do it when the Product Details component unmounts, I think.  The problem with that is that if any part of the form is valid, ALL dispositions would be lost, which is shitty.  

    It's annoyingly hilarious how much every problem keeps coming back to "none of this would be a problem if there was a Submit button" 

    I also can't escape the feeling that I am making this more complicated than it needs to be.  

21 Dec 2022 

    On the docket for today:
        -Need to figure out how to display the warning, probably with a side effect.  
        -I should look into how to use refs.  I want the input field to be focused every time someone clicks one of the disposition buttons.
        -Before I get farther, I should probably figure out how to handle tax.  Like, it's not going to be fun but if I don't handle it now that could legit bite me later.

        -First.  The display warning.  I THINK I can just handle it in the input change handler?  

    12:00 - I do know why I am stuck.  I feel like I am violating DRY because I'm doing similar operations in similar places, but I don't know what would be better.  Just right now I feel not smart enough to find the patterns.  

    I also just found out that the current app DOES use a Submit button, but since I think the local validation is important and I wouldn't want to have to re-create it in another prototype, I'm just going to keep it for the time being.

    Just really not feeling the magic today.  I think I'm going to skip the redose, but I will try to work up until the painting party - which I am also not at all sure I'm going to do.

    4:50 - Got the painting party going in the background, so glad I decided not to participate.  My intuition that the existing code was flabby and repetitive was totally correct(I think).  I had a cool new insight:  since we're treating each change in the input independently, I should delete the current property being evaluated from the local Dispos obj IN EVERY CASE.  If the value has changed, the old value is meaningless.   Now I am having fun :)

    Mostly working.  Bug to attack tommorrw - I get the error message when I backspace a formerly valid number to "" in the input field.  Otherwise appears to be working correctly!

    Today started out bad and I'm glad I stuck with it.  This turned out really well.

22 Dec.  I can't remember if I already took a pill this morning, so I am taking one now.  It's either going to be a good day or a REALLY good day.

    First thing to do:  I am going to use my new debugger tools to try and re-create the error in the Item Entry field.  

    -I also need to turn off the increment arrows

    -I also need to clear out all the commented code.  That SHOULD be it for item entry. 

    -OK, looks like the problem and solve are pretty clear.  Turns out the typeof NaN is ... "number" :/   Yes, kids, Not A Number is actually a number.  Any numbers added to NaN disappear in to the void, resulting in Nan.  So, the first condition acutally failed to separate the NaN conditions, allowing a non-number value into the system.  The larger or smaller evaluation included the inputQty, so that evaluates to NaN, and because we are checking relative sizes of NaN and a number, it always evaluates to false.  My returning objects are false by default and they are never modified, so the IsValid state returns false.  Hence the error.

    And I doubt I would have figured this out without the debugger. 

    Also, I want to record this because I think this is actually a turning point in my growth.  I think I needed two additional tips to use the debugger.  The first was to use custom break points.  Because I'm using a framework, Step Into (F11) would take me through a long and incomprehensible sequence of framework code any time I used React-specific methods (like useReducer) in my code.  And also you can't step back, so if I was frustration-clicking to get through all the boilerplate there was a decent chance I would blow past the code I actually wanted to see entirely.  By using custom breakpoints, I can make sure I'm stepping where I need to.
    
    The second, related change was to set the F5 key to be 'Unpause'.  I remember having all of these frustrating moments where I would be stepping through with F11, get frustrated, hit F5 to step ahead, and then find myself back at the beginning of the program.  Well, the connection that I failed to make was that the Unpause key is different in Chrome and VS Code.  Chrome wasn't behaving unpredictably - it was refreshing the page, which is what browsers are supposed to do when you hit F5.  I think that was also the source of a huge amount of frustration.

    Finally did it!  input validation is finally working just how I want it to :)

    -The next thing is to figure out how to handle tax.  I really do want to move on, but the RefundTotal component is used in other places and if I don't address it now, it could cause rework later.

        I am HOPING this shouldn't be too hard.  I THINK all I need to do is add a   tax   property to each invoice product's object, next to price and quantity.  I'm representing "How much you paid, and how much of that was tax"  When I am matching an object, that price and tax can just be copied together.  With quantity, I can calculate the total tax and total price.

        I don't want to go with a single rate because, like I saw in Connecticut, not all products have the same sales tax.  Like if a state has a sugar tax and the customer bought a soda, they would pay different from the normal sales tax.

        -I've also realized that the TRUE full form of this product would accept multiple payment methods on an invoice (like using up the last of a gift card and then paying the rest in credit) and might need to have multiple quantities per item, but I don't want to have to deal with that right now.

    -instead of thinking in my head, I suppose I could think on paper.  
        -I did what I needed for the matchmaker.
        -I'm now looking at it and I want to make 2 changes.  
            -First, I want to use the squeezer at the start.  I think this is actually what I cloned the squeezer from.  This one I should probably do.
                -I might also change the output names.  Right now, the squeezer is only used in 2 places.  Again, now would be the time.  

            -Second.  More dicey - I notice a lot of repetition in object values I'm referencing: like  one[two].three[four] which I could and probably should clean up with variables.  BUT.  Do I really want to spend even more time on the Matchmaker?  

            -If I'm going to do it, now would be the time.  I'll just be adding dependencies later and it will get harder to change.

    -Seems to be going OK, but I ran into a bug where an item matched and it had an empty dispos obj in its array.  The item was 200, qty was 4, and I had AAA, BBB, and CCC invoices scanned.

    -OK, got it.  Matchmaker is now working, I put it through a couple scenarios, and so far it is working as expected.  

    3:00 gonna have some Soylent and get back to it.  I feel pretty good but I also feel like if I lose momentum it could be hard to get back.  10 minute timer, go!

    UGH.  For fuck's sake.  Now something else is happening in the matchMaker.  

    OK, problem fixed.  
        A couple of takeaways.  First.  I am a little concerned about the fact that I still don't REALLY have a conceptual model for what the Matchmaker is doing.  I really wish I could conceive the fractal pattern.

        Second.  I REALLY need to remember to not do multiple changes between commits unless I am REALLY confident.  I took a LOT longer to solve that problem because I assumed the problem was truncating my object 'addresses' with variables, when it was actually that line that check if the invoice still contained any of the item in question.  

        Also.  You know what?  Good on you for noticing the problem!  You at least know enough to know that a matched item should NEVER have 2 of the same dispostion in two different arrays.  The Matchmaker clears out every disposition sequentially, so that can never happen if it's working right.
    
        -FINALLY for the Returns Total.  Feels weird to be looking at this again, like it was so long ago :/

            -I now think the Return value calculator should be a separate module.  

            -First, we need to get the Matched Items from the Returns state.
                Loop through each matched item
                    Loop through each item's array of matched objects.
                    For each object, apply the Adjuster()

                    For each Matched Item, we should get:
                        Total paid sum
                        Tax sum
                        Adjustments (if any)

    SessionItems: raw count of all the items scanned in.
    SessionInvoices: raw count of all invoices being considered.
    matched_items: a list of all items that have been matched.
    unmatched_items: a list of all items that have not been matched.
    
    returnTotal: {
        refunding: [
            {
                orignalTender: "cash"
                refundTender: "store credit"
                refundAmount: 123.45
            },
            {
                orignalTender: "Visa ****1234"
                refundTender: "Visa ****1234"
                refundAmount: 8.76
            },
            ...
        ],
        refundTotal: 98.13
        subTotal: 78.10
        tax: 10.03
        adjustment: -10.00
    }

    So.  

    MATCHED_ITEMS will take SESSION_ITEMS as its only input.

        RETURN_TOTAL will take MATCHED_ITEMS as its only input.

        Adjuster() will take accept an object of all MATCHED_ITEMS, go through them, calculate price Adjustments based on conditions, and return that list of items along with an Adjustment property for how much the return value is getting reduced.

    I think that means that any manager overrides need to happen at the level of SESSION_ITEMS.  BUUUUT.  Some of the declines can only happen after the item is matched, like if it's past 90 days.

    And the problem with making adjustment-adjustments at the level of MATCHED_ITEMS is that MATCHED_ITEMS isn't stored.  It's recomputed literally any time the state changes, so any overrides applied here wouldn't even be kept.

    How about this for a model?  AFAICT, there are no adjustments that interact with an invoice.  
    
    I think that Adjustments happen for an individual item, like the SOS restocking fee.  That should live on the item {actually, in the that item in the product-store}, and manager interaction just removes the adjustment from the item in SESSION_ITEMS.  Once it's gone, it's gone.  Since it happens in SESSION_ITEMS, I can recompute MATCHED_ITEMS as many times as I want and the MO will still be in effect.

    Meanwhile, for the outright rejections, manager override takes place in the derived states.  What I'm thinking is that that I'll have a separate OverRider() that accepts UNMATCHED_ITEMS, goes through, and generates a Magic Invoice for all legal (non-ARD) unmatched items in the cart, with the return tender set to Store Credit.  It then adds that invoice to the list and all remaining items get matched.

    Could also work well if customer is LVC.  If you are in the sytem, you just get the magic wand with no further input required.

    I like it.

    That still doesn't tell me what to do about ReturnTotal, though.  I also don't know what to do about ReturnTender types, or when those are computed.
        -Here would be my guess.  The unique key is the tender-in / tender-out pair.  Tender-in is always known.  I think that screen with the green circles is where tender-out is determined.  For any with no choice, it just grinds through automatically, and if there are any uncertainties, that's where the associate is asked to make a choice on screen.  I think that builds your complete list of return modes.

        -That's also good for me.  I think for right now, I can just calculate Total, Subtotal, Taxes, and Adjustment for the ReturnsTotal component.

    I'm also a little unsure what to do with the dispositions.  Like, if it's Defective then we don't apply the restocking fee.  When do I calculate that?
        -First of all, this should be a VERY limited case.  I actually only think it applies for an SOS item that has been damaged.  
        -I think the rule should be that if there is an adjustment it applies to all non-damaged items, unless there is a manager override in which case it is removed entirely.

    -I remember.  Receipt Date.  I mean, the easiest is to add a condition in the matchmaker that just doesn't count the receipt if it is older than 90 days.  The ONLY catch that I see is I think we have to show too-old-receipted returns separately.  I guess my tentative solution would be to have a separate function that goes through the Unmatched items after the Matchmaker, looks for matches with old receipts, and stores them somewhere else.  That's a simple-enough add later that I think I just ignore it.
    
    Now, for ReturnTotal.  We have some flexibility when to calculate adjustments.  Those could happen at any time ReturnTotal outputs.
        -What I'm thinking right now is I add a Special Conditions object to each item in the product catalog.  This will specifically hold things like ARD and SOS.  

        -Next, I have an Adjustments() method.  It will look for anything that changes the price, like SOS.  All adjustment percentages live in this tool so we don't have to change 50 billion entries if I decide to change the percentage.

        -Oh, fuck.  The percentage.  That could change too.  That is going to change, too.  We're going to give the manager the ability to adjust fees.  And I think it's per item.  OK, well, never mind.  

        -I mean, I guess the VERY easiest way would be to have an adjustment % on every item.  Maybe in my Special Conditions object, it looks like {SOS: 0.2}

        -Then, if there is a manager override, that percentage is changed on the SESSION_ITEMS.

        -If the adjustment percentage lives on the item, I also have the ability to display it, its percentage, and its reason code on the list of items, although I still have no idea what to do on price.

        -If there were ever a situation where multiple adjustments collided I could put the logic for it in the Adjuster.

        -No matter what, the end result of running MATCHED_ITEMS through the Adjuster() is going to be a modified version of MatchedItems where each object includes an Adjustment property along with price, tax, and quantity.  That will be the amount by which to reduce the return price.

        -Because of this, I'm now wondering if the Adjuster() should happen at the end of the Matchmaker.  Or maybe even in the middle?  Or, actually, I think it should be happening on ADD_ITEM?  Like, at that point we should already know everything we need.  Wait.  No.  We don't, because without the invoice we have no idea what price we should be adjusting.  OK, I think within the Matchmaker is correct.  

        -What if more of the same items are added later?  Adjustment percentage should be the lowest, I think?

        So then I think what we do is Adjuster(rate, matchedObj)=>{} in Matchmaker and ... and no.  Because we still don't have the dispositions. 

        -Crap.  Since the dispositions may be mixed, I can't just provide a flat value.  Like if I have 2 damaged and 3 unwanted, I can't specify one one number from which the Adjustment can be calculated.  Maybe I should calculate Total, TotalTax, and Adjustment in each object.  I mean, we're going to have to do it sooner or later.  

23 Dec 2022
    God, I wrote a fucking novel last night.  I also have only about an hour before  I need to head out to the doctor, but it's for my knee so that is also very important to enjoying life :)

    -Very first task in the queue today is figure out a plan of attack for how to handle the CostAdjuster().  

        -OK.  So.  Every loop through the dispositions will produce at least one property, and fill up the disposition: property until either all item dispositions or sold qty are exhausted.

    200:{
            specialConditions:{SOS: 0.2,}
            matches:[
            {
                price:44.00,
                tax:4.10,
                payment:"Check",
                disposition:{doesntWork: 8, unwanted: 4},
            },
            {
                ...
            },
            ...
        ]

    }    
        -I guess my first thought would be to calculate return value as I am looping through the items, but to do that I would need to know the special codes.  Although I guess I need special codes no matter where I loop from.

        -Rules:  SOS item - NEVER without a reciept, 20% with a receipt.
        -ARD: Never without a receipt.

        OK.  So I shouldn't have to worry about that here.  If they are matched then by definition they have a receipt. (that's what they're matching with.)  So the only think I need to be on the lookout for is adjustments.  

        I can either cumulatively calculate the total value as I go along, or I could do it after the full array of the item's matches are completed but before it is added to the MatchedItems object.  It might be more efficient to do it that way, but it would be much easier just to pass the whole object.  

        That's what I'm going to do.  Maybe it's more efficient but this way is easier to understand.

    After giving it some thought.  I think what I want to to is store cost inside each receipted item's > match array's > matchObj.
    That seems like a lot of extra data that I'm not going to use right now, but when it comes time to calculate how much money is being reimbursed to each tender method I think it will be really helpful.  

    Input/Matching:
        Revised Invoices:
            -How many items were returned from each invoice.
            -How much was paid per item, per invoice.

    Tenders/Refund:
        -Total sum paid for each item type per invoice.
        -Total sum being refunded per invoice
        -Tender type(s) per invoice.

    Remember, per receipted ItemNumber(200), each match array's > matchObj represents matches made from ONE invoice.  So as long as each matchObj also contains the invoice number from which it matched, having the cost already calculated and ready to go should make converting the MATCHED_ITEMS list into the Tenders/Refund list pretty easy.  Just cycle through the Items list and check if it came from the Invoice in question.  If so, add its costs to the total being refunded from that invoice.  AFAICT, I don't even need to know what the item is - item totals in MODIFIED_INVOICES has already been updated in the Matchmaker.  

    5:30 OK.  Hold up.  If that is the case, I might as well just handle it in the matchmaker, right?  For the time being, I'm just going to add a restockFee property to each item.  Calculating that can be the back end's problem.

24 Dec 2022 - Finally back after a morning power outage.  What a waste.  I couldn't get back to sleep after my CPAP was unpowered, and I legit think I could have been in this seat at 8:30 instead of like 12:30.  Nothing that can be done now.

    -What can be done now.  I need to get the Session state from Returns into RefundTotal via its parent.  I can't think of a time when I would be referencing anything else, so I don't think I need to accept the object as a separate prop.

    -After that, I need to figure out how and where to set the Continue buttons and have it track if there is anything in ScannedItem, and I legitimately think I will be ready to move on.

    2:40.  Well, that was pretty painless.  The ReturnTotal component is correctly showing totals calculated from Matched and AFAICT it's working just how I want it.

    Next question - what is next?  I supposed before anything I need to get the Continue buttons working.  I do like the idea of having Continue present from the ItemDetails state, but I think I will not.  First, for testing I might have to go back to having the Submit button here.  The other reason is that it's kind of an anti-pattern, because at L1 and L3 of the three the button in this spot continues, but at L2 it submits an item?  Not so sensible.  

    I swear I do want to move on, but I think I should add 2 QoL features.  First, hitting the Damaged / Defective button should set all dispositions to {}.  Otherwise it's not doing much.

    Also, I don't think it would be too hard to implement the Reason buttons showing their current quantity.  I just show the quantity from the global state.  That way, the user won't see the number change while they are typing?  Or should they see it?

    3:20.  OK.  40 minutes invested and both of those QoL features are working correctly!

    Now, to deal with the buttons and Continuation.

    5:10:  OK.  I'm doing OK today.  I finished up all the work for populating the ReturnTotal object and it's all working.  I've also got a new empty page with a new URL for the FirstReview component and navigation to and back is working correctly.  The next steps are going to be to make a couple of universal components - the in-page title and the Review LIs and honestly the thought of having to consider all of the use cases I need to consider to make then reusable in different configurations seems a little intimidating.  I think I'm gonna swalk, see how I feel, and only if I feel like it when I get back will I get after that next step.  I'm feeling a little down because I mostly did easy things today, but a lot of that easiness is familiarity and the fact that I have been working REALLY hard to apply the Robustness principle so that I don't make hard future steps for myself.

    Like... a lot of this stuff is smooth because of foresight.  Setting up Returns to hold universal state, and then having all the page displays on URLs so I can easily change pages while having unbroken access to the data?  That was preparation.  

25 Dec 2022
    Christmas calls are done and I need to wrap up and get on the road before too long.  However, I'm going to try to code one last little bit before I go.  Before I go, I would like to have:
        -A new, scrolling table
        -A new, custom ReviewDetailsLI component
        -Table populating from Unmatched and the new custom LI.

28 Dec 2022
    I'm really dragging ass today.  I could conceivably have started 90 minutes ago but my heart just isn't in it right now.

    -First thing for today.  I need to continue to build the list item for the non-receipted returns.

    -I also need to figure out what the hell was happening when the screen was at a shorter vertical height.  That was kind of ugly.

    -I need to create a container for the next phase, which is Lookup, and add a Continue button that leads to it.  

    12:30 - still not super engaged, still kind of going through the motions, but that is better than not going through anything :)

    -I've got most of the content added into the Review LI.  I just need the Rejection code.
        -Make list of areas where rejection codes are used.
            -Non-receipted review
            -Rejected Review
            -Sometimes in the raw Item List

            -OK.  So AFACIT, these codes are only used in relation to items, and I THINK they're all in relation to either Session Items or Unmatched Items which have the same structure.  I think what I am going to do is let the Rejection Code component accept a function, but also have a default function that works on the Item data structure.

        -Figure out how to display rejection codes.  Maybe the component accepts a function?  Or maybe there is a function in the component?
        -Create a Rejection Code component.

    3:30 - RejectionCode component is now working correctly.  I think I just need to do some CSS cleanup, add the button, and then move onto the next phase.

    4:30 - Fixed the CSS and took a short break.  
        -Next, I need to create two additional pages: a Total Review page and a Search page.  I also need to set up conditional navigation so that if there are no unmatched items, the user skips straight ahead to Total Review.  Then I can get cranking on the Search page.  I'm finally feeling good and engaged and ready to regret the 90 minutes I spent goofing around this morning :*)

    7:40 - Fuck.  I am really stuck with ReactRouter.  This reference has been pretty helpful so far: https://ui.dev/react-router-tutorial

29 Dec 2022
    9:40.  I'm already ahead here :)  First, it's before 10 and 69420 is already underway.  Second, I consciously made a decision not to do some web surfing, which is how I got into a stimulus cycle yesterday.  Also.  This was a little display of courage.  This is probably going to be an unhappy, frustrating experience and it would have been very easy to put it off.

        -So.  Task number 1 for today is to solve a mystery.  Why are my links to the other two pages not working?  

            -Remember what Harrison taught me.  Rather than guessing at one thing after another, try to cut the field in half as many times as possible.  Treat it like a game of Boticelli.

            -Try loading one of the pages in a URL link that I know is functional.  I assume the page contents themselves are working and I should verify that.

            -Try making one of the non-working pages the only URL at the same level.

            -Find out all you can about the Outlet component.  Not sure if they should be nested.  

            -Take a look at the Components tab in the browser.  AFAICT it lists available links.  

    10:10 - OK.  Already got something good.  I tried to use <ReceiptLookup> component in place of the very basic "Start Scanning" piece in the index component <StartScanning70>, and got the same error I got last night. I also got the same error in <TotalReview>.

    Just to be sure, I tried putting in the <FirstReview> component into <StartScanning70> and while it looked a little funky, there were no errors.

    This tells me there is a HIGH liklihood that something is wrong inside the components and not with my routing or links.  Here's the messaage I'm getting:

    ----

    Uncaught TypeError: Cannot destructure property 'to' of '_ref3' as it is undefined.
        at Navigate (components.tsx:176:1)
        at ReceiptLookup (ReceiptLookup.js:7:1)

    ----
    
    -The fact that the first error in code I've written is appearing in ReceiptLookup.js:7:1 is super suspicious because that's where I'm defining the Navigation hook.  

    GOT 'EM!  I was importing Navigate (a component) instead of useNavigate (the hook)  When I changed that, it worked perfectly.  Still gotta do some fiddling to get my routes to work right.

    -Route and Path:  From what I can tell:

         <Route path="/returns" element={<R/>}>
            <Route index element={<RI />} />
            <Route path="first-review" element={<FR />} />
            <Route path="receipt-lookup" element={<RL />} />

        Any path that has only 
            /returns/
        will render to the Returns index.  
        
        A link to    "first-review"     from that index will take you to:
            /returns/first-review

        Now here's here it gets tricky:  If there is a link in 
        /returns/first-review    with a path of   "receipt-lookup"   then it will take you to the URL of:
            /returns/first-review/receipt-lookup/
        
        even though they are siblings.  AFAICT, if you want to navigate to a sibling, you have to write that path as:   "../receipt-lookup"

        -One other thing to pay attention to.  Normally, ".." navigates one level up in the route, so if I am at:
            /returns/first-review/receipt-lookup/

        then I would go back to    /returns   because 
            <Route path="receipt-lookup"> is a child of 
            <Route path="/returns"> in the Route hierarchy.  

        If I change the <Link> component to include property 
            relative="path"   then I am taken to:
            /returns/first-review/
        Because of that extra property, I'm now going up one level in the URL, not one level in the route.  Apparently this is because URLs can include URL parameters and those can be conditional so you don't even necessarily know how many URL segments you will have at any given time.  Because of this, it's normally better for ".." to refer to the route rather than the path/URL, since relationships in the Route tree are always known.

    -11:20.  I'm feeling really good.  I've already solved my biggest problem of the day.  Like, I was legit prepared to spend all day on this, and I'm already done, and at this time yesterday I'm pretty sure I hadn't even started :)  Just want to get down some takeaways.

    -First.  I need to be REALLY aware of when I start scrolling, either on my phone or at the desktop, because once I do it that's a great recipe for an hour to slip away on nothing.  It would be helpful to come up with an approach or a mind tool like 69420 that would prevent that.

    -Second.  I wish I had taken this approach last night.  I was kind of on the right track when I came in from my swalk to check that the component path was right.  But I need to be very careful of syntax-guessing.  It's really appealing because it's always got the potential to make the problem go away on the very next swing, but I think it's dangerous.  

        -My first question should always be:  Am I 95+% sure I know WHERE the problem is occurring?  If the answer is yes, I can continue syntax guessing.  If the answer is no, I should immediately stop and start cutting the field until that number is back over 95%

        -With every wrong syntax guess, my confidence that I know the problem's location should be going down.  I think if I make 4-5 wrong syntax guesses in a row, I should probably stop and do some field cutting until that number is back over 95%.

        -Remember the number game.  I'm trying to FALSIFY my top guess, not confirm it.

    -11:30 OK.  Back to work.  Gotta remember that Adderall tends to make me typey and I'm here to write code, not this journal.

        X-First.  Need to go through and clean up the routes and make sure everything's going where I want.

        X-Need to add a conditional in Actions30.  If there are items in the cart but no Unmatched, we go straight to Total Review.

        X-I really do need to modify the SessionItems70 table so that if there is a restock fee it is visible.  

        -Do I want to do the Manager Login today?  Those two kind of go together and it ~shouldnt~ be too hard, right?

        X-I need to fix the CSS for the button.

        X-Do I need to add a property into the TitleBar to optionally make the button a nav link? 
            -Right now, I think the answer is no.  The only reason I even considered it is because I read somewhere that useNavigation was bad in some way I don't actually understand, so I think I sit tight.

    2:20 - Everything is done except the fee waiver.  Right now, my inclination is to just leave it.  First, it's probably going to change.  Second, I feel like that's a pretty self-contained little chunk that would be good to hang onto for if I am having a bad day and want to put a win on the board.  I'm gonna move ahead.

    4:30.  OK, went down a bit of a rabbit hole with the borders but I think we're good now.  Literally just ran into a snag.  The Returned Items and the Mini Unmatched LIs are so similar that it seems like a waste to have both.

    7:00.  I think I'm actually gonna call it a night.  

30 Dec 2022 
    9:50 a.m.  I feel like I got out of the gate pretty well this morning, and yet here it is almost 10:00.  Anyways!

        -First, I need to make a decision on the Invoices LI.  I could either directly have a mode, or just have each condition not display unless it's explicitly got a value.
            -I've elected to conditionally display the values, just in case.  However, I've got another problem.  This component is going to get fed from both Unmatched Items and Matched Items and they both have different data structures.  I think maybe I should change this component to accept all values that it displays through props?

            Actually, no.  If I have a situation where the itemObj doesn't match, I can just reprocess the itemObj as necessary.  Let's at least optimize it for one scenario here.

        -I think I need to make either a component or a set of CSS properties for the message badges.  I should also check to see where else they are occurring in case I need multiple sizes.

        -After that, I should be able to get into the Search.  I'll need a title, buttons to select search modes, and then figure out how to conditionally render the input field collections 

        -I probably need to make icons :/  I might just bypass that because IIRC icons were a huge pain in the dick and they have no dependencies.  Although that might be a reason to do it, since I don't like doing it and if I don't I might never get back to it.

        That should be good enough for today.  I won't get through all of that and if I do I definitely deserve a swallk.  

    11:00 - Spinning wheels here, as I usually do when I am uncertain.  I think the thing to do is put a win on the board here, and I think a good one would be the message ribbon.  

    12:00 - Yup, kind of sucking right now.  I'm always most vulnerable when I'm not sure how to proceed.  I'm not getting pleasure from action=>result, so I seek it from time-wasters.

        -Let's buckle down here.  We know where to start looking.  The universal header isn't displaying space around the ribbon the way I want.  
            -First, I want a default size that grows with the contents.  I think I already have that.

            -OK.  I actually think I can just toss all the contents in there, justify-content to center, and let the browser deal with it.  


        -But first, let's check the inputs to the ribbon and make sure it's working as expected.

    1:40 -  I think I'm finally ready to get going on the Return Search.

        -The thing I least want to do at the moment is setting up the layout and CSS.  I guess that means that's what I should do first.

        -Two things to do next.  First, I think I need to make a function to produce the buttons.  Othwerise I expect to be doing a lot of copying.

        -Second, I need to figure out how the hell I am going to handle 8 different input types and texts.  My current thought is to just do it as an object, have the keys match the possible state names, and then in the JSX set it to {inputs[stateName]}

    3:00 - I'm making an executive decision and going rogue here.  Search button is going next to the search bar.  The current position is retarded and I refuse to be a part of it.

    4:20 - Well, I got kind of stuck and I didn't immediately stick to my problem-solving paradigm, but I eventually remembered it and figured out the solve pretty easy (I mis-ordered the state and action in my reducer definition)  

    5:20 - OK.  Potential problem on the horizon.  Some of the components have more than one input field.  I'm actually not super worried about the input state - I'll just make the payload an object instead of a string.  

        -I am potentially worried about how to conditionally render the input fields, as well as how to perform the search.  As long as it was a single search field and a label, I could generate it out of an object, and all I had to pass to the search function was a search term.

        -Christ.  So.  Each object I'm passing into the Search Input Renderer needs:

        key(a search type matching a button):

            -1 label

            - (n) input fields, possibly with custom CSS.  (realistically this is probably just a full custom component)

            - an empty object with properties corresponding to the input fields with which to  set the   fieldInput: ""   state.

            - A function() to validate those inputs.

            - a function() to run that returns whatever invoices meet the definition of a 'match' for this particular search type.

        OK.  Let's be cool here.  I think there's a decent list that I can do with one input field, which makes the task significantly easier.
            -Credit Cart
            -Phone Number
            -Order #
            -Pro ID
            -Commerical Account # (minus the lookup fields)
            -MyLowes #?

        I'm not sure about Checks or Vendor PO.  I just don't know enough.  But that still gets me to 5.5 of the 8 search fields I know of.

        So what I can do is have a standard function that makes all the one-liners.  I can fill the object with its contents and then if I need to make more, I can populate it by hand if necessary.  


    7:05 - Just got back from a swallk.  I am just flying right now.  I am so excited about the possibilities of this input field component that I'm gonna keep going.  Experience has also taught me this means I have about an hour left before I completely lose interest and am done for the day, so we will see.

        -it would be REALLY nice to have a standard Input component with inlcuded warning text.  I would want it to:
            -accept a validation function from above
            -allow use of useEffect and maybe a delay parameter to only validate after some amount of time.
            

        -The thing is, since I am going to be making so many input fields (and because I have so many already) this probably needs to happen pretty soon.  
        
31 Dec 2022 - 
    9:20 - Even with a weak start I'm still underway at a decent hour.  The big open question is the input fields.  I think the thing to do would be to commit an hour to it and re-evaluate.  I don't want to be here with it all day.  

    9:50 - At least at my skill level, I don't really know how to make an component that does everything I want through props.  
        -The primary problem I need to solve is that I do not like the error messages appearing when the user is typing or hasn't entered anything.

            -I think the VERY simplest way to do this would be onBlur.  
                -When the field loses focus, the validation function runs.  Actually, I will probably have the validation running as part of the input process.  The onBlur operation would just display the error or not based on the input's validity.

            -The other approach, closer to my ideal, would be to check after some time has expired.  

    10:30, wondering why the hell everything seems so much harder today, and then realized I haven't taken my pill -_-

    -So, like...I've done all this work on the input component and  it just doesn't look any easier than doing it by hand.  it saves a little typing and now I have less flexibilty.  On the plus side, I think I have my answer?

    11:50 - just feeling, like, really slow and dumb right now.  I wonder if I'm not making the problem harder than it needs to be.  

        -OK.  I do not want to be here all day.  What I really ought to to is just make the basic, one-line search field.  The problem is that I have resolved to do this like, four times this morning and every time I am about to make the decision, it comes back to: "Welllllll, if only it accepted a child then I could make it reusable.

            -Maybe I've got the wrong approach.  Maybe the basic form is JUST the input, the submit button, and the error.  But if that's the case I could just stick the damn title on and be done.         

        -Gotta think a little about the matching function.  Almost everything can be stored in the InvoiceDetails section.  
            -AFAICT, the payment info isn't used anywhere in the Matchmaker so I should be able to use it safely.
            -In that case, I think the correct play is: 

                invoiceDetails: {
                    payment: {
                        cash:{paid: 12.34}
                        credit:{
                            paid: 12.34
                            ccNum: 1111-2222-1111-2222
                        }
                        check:{
                            paid: 12.34
                            routing: 12341234
                            account: 43214321
                        }
                    }
        
            -Also need to remember - for Search, the amounts paid DO NOT MATTER.  All we are trying to do is find more invoices.  Amounts paid can be handled on the other end.

    4:35 and still feeling pretty dumb, like there's a much easier way to do this that is eluding me.  The RLsearchFielder at this point has shrunk down to nearly nothing and the only reason I have it at all is to make the code shorter.  Like...I think honestly I just eat the length and do it all in the ReceiptLookup component. 

    4:55 - OK, there's definitely some CSS fuckery I should take care of, but that's easy.  Top priorities:

        X-Get the text length validation working.
        X-Ensure that the submit button is properly calling the InvoiceMatcher and sending a string to it.
        X-Actually, that should be an object, since both the search type and the field value are necessary.
        -I need to get in there and actually populate the other 4 fields.
        X-Fix the CSS.
        X-Search button should hide or be inactive if the input isn't valid.
        -IF I want, the invoiceMatcher could return some info about what it found, since its main function will be to update the session items.
        -When  minumum effort === true, show the Continue button in the parent.
        X-Figure out how we want to display the in-page title.
        
        -I actually really would like for the component to accept a custom validation function but remember rule 1.

    -Not really related to the work, but I have been REALLY happy with the onBlur validation.  It seems to really work the way I want it to.  I wonder if I could package it.  
        -I would need to assume any input state with validation is going to have input, a validity state, and a ShowMessage state.  I THINK the handling for all three would have to occur outside the field.  Still, could I configure the field to expect those three states, and assign them to value/onChange, and onBlur?  Maybe?  

    -It's also occurred to me that since I am tracking the state in the individual search fields and not in the top level component, if Kristin wants me to put that button back where it came from it's going to be a lot of work. 
        OK, so I would have to:
        -make something, probably the 70 panel, into a form.
        -Track and handle state in the top-level component.
        -pass the state and dispatch to each child.
    -I'm just gonna do it.  This is probably what it should have been anyways.  And that will probably be it for me tonight.  

    8:55 - Damn, that went surprisingly well.  Got everything ported over and it's now working as expected.

    9:40 - I'm really in a groove and I could honestly keep going but if I don't point my mind at something else I won't be able to sleep tonight.

1 Jan 2023:
    9:55 - First entry of the year!  OK, today SHOULD be a decent start.  
    
    -Very first thing is to get to work on the invoiceMatcher.  Should just be some pretty straightforward Javascript.

    -Next is the SecondReview page where it shows all the rejected items.  Again, should be pretty easy.  After that, I have to make a decision.  
        -I COULD get into the Manager Override work.  Not the worst idea in the world, considering I have to prototype it pretty soon.

        -The other option, which I currently prefer if I had to pick right now, would be to skip the overrides and go right to the end.  AFAICT, the two last BIG challenges in this process is going to be the Total Review and then the Stepper-Refund walkthrough.  

    -Running into an issue with the Context.  I actually do not understand the problem but it seems like you cannot useContext inside something that isn't a React component?
        -I'm looking at the matchMaker and AFACIT it doesn't reference any external states.  Actually it gets passed two objects, which might be a mistake since those values never change?

        -OK.  I am going to try doing this as a non-UI component because 
            a. I don't know how to do that and should probably learn.
            b. That's probably what the matchMaker should be, and I should probably learn.

    -Side note.  I feel like I'm struggling here.  I know *A* way to do a lot of different things, but I don't know the *best* way to do anything and I feel like I'm mostly relying on familiarity rather than an actual understanding of what's happening.  I badly need a mentor :/

    -OK.  Turns out I didn't solve the problem at all.  The reason I'm not getting any errors is because my InvoiceMatcher appears not to be running at all :/

    -Well, I still don't understand the problem.  My best guess is that I am breaking the rule that hooks can only be called inside the top-level component, although I have no idea why that would be.  
        -I think what I need to do is just stop bucking, pass the state as a parameter, and move on.  I've spent waaaaay too much time on this already.

    1:50 - OK, let's keep this brief.  I'm struggling because I was in a situation with rules I didn't understand (Hooks needing to be called together at the same level) and I didn't build any momentum in the critical phase.  I now have an inelegant solve, and I should be able to move ahead.  Let's try to jam hard for 45 minutes and see if we can't get our mind  unconstipated.

    2:35 - And now I just found out that while I can't use a hook to get the context which never changes, I somehow can dispatch to the Returns state from within the InvoiceSearch function.  Fuck me, I guess.  God, I know so little about what is actually happening :/

    4:30 - and now the props aren't passing in correctly, and they were just a few minutes ago.  Sigh.  OK.  Let's un-fuck this.

    4:50 - OK, it's working again.  I HATE having to pass props in order, but I'm really having trouble making it work with an object and this is a stupid thing to be spending time on.
    
    5:00 - I think I'm going to call it a day.  I didn't make progress and I didn't handle the lack of progress very well.  Instead, I have a new mission for the day.  I'm going to walk and remember that I've had DOZENS of bad days like this in my past, and not one single one stopped me from being on a fucking roll the way I was this week.  

2 Jan, 2023:
    First day back at work.  I don't have any meetings today and I was thinking about slacking off, but I apparently have my 1:1 with Liz tomorrow and if I could get the matching to work, that would be sweet.  I actually think I have most of the logic sorted, so I just need to run through it in Chrome and see what I get.  

        -First, I need to figure out what to do once a match is found.

        -I think my VERY top priority should be to get it working.  If that means multiple dispatches, so be it.

        -Time allowing, I can set up the Returns reducer to accept an array, destructure it,  and put everything it contained into the new Scanned Arrays state.

    3:45.  Well, against all odds the InvoiceSearch is now working just fine.  I want to clean up the TotalReview page b/c it's an ugly shitstorm right now, and maybe add Rejected Items, which SHOULD be pretty much a clone of FirstReview.  In fact, maybe I should just modify FirstReview?

    5:30.  Well.  Would you look at that.  In spite of waking up dragging ass and STRUGGLING to get going, everything up to the second Item Review is now working as planned.  Talk about a come-from-behind victory!  I was sure this would never be a swallk, but I honestly think I've earned it.

3 Jan 2022.
    -First, I'm gonna push a build to my Github Pages account in case this goes horribly wrong because I'm gonna show it to Liz in about 4 hours.

    -Then, I'm going to move the contents of invoice-context into a variable and return that variable so I can do operations on it.  My understanding is that since it is not a state, the math operations should only happen once.  

    -BUG to fix:  If I have Item A visible in the ProductDetails30 panel and then select a different item, the panel doesn't update and show the dispositions of the new item.

6 Jan 2022
    12:40.  Honestly I'm not doing great today, but I am going to at least try to make some progress.  

    The BIGGEST thing that needs to be handled is the fact that when I change items in <ItemDetail30> the dispositions being shown are not from the new item.  There are two issues I need to clean up.  

        -First and most important - When I change items, the Reason buttons and their quantities need to reflect the current item.

        -Second: From what I heard yesterday, Didn't Want / Need is going to need its own buttons.  That means:
            -Buttons need to accept an argument for which object they read from / write to.
            -Clicking Didn't Want / Need should no longer clear all dispositions.  Actually, it probably shouldn't do that to begin with.

    -OK.  What I noticed is that the buttons are reading from the local state, when they ought to be reading from the global state.  It's reading from a prop, but any change to that prop SHOULD be triggering a re-render from a parent so I don't THINK this should be a problem?  

        -So.  The quantities are now correctly displaying, but when I change items, the input field doesn't change, and I've also noticed that the localDisposObj stays the same.  When a new item is clicked, the localDisposObj SHOULD become a clone of the Global dispos obj for that item.  

        -Here is my current best guess at what is happening.  When I click on a new item, I am changing a prop, not a state.  AFAICT, everything that does change correctly (picture, qty, etc. ) are all using that prop as part of their route.  so like the image is   image[itemNum]   and I THINK that if itemNum changes, anything references itemNum now points through its new value?

        I keep thinking to just put a local state in there that tracks the ActiveItem, but I already kind of have that.  That's what's set by clicking on any <LI> in SessionItems70, and that state's value gets passed as a prop into ItemDetail30.

        Here's where I'm stuck.  I THOUGHT that since every time I clicked on a new item, I was triggering a re-render.  My Reducer contains a function that sets the state initially, and so I thought that every time I triggered a re-render, that would get reset.

            -That's an assumption.  I don't actually know if it is the case.  I will put a console.log in there.  IF my understanding is correct, I should AT LEAST see it ping every time I select a different cart item.  
            
            -HA.  OK.  So that solves part of the mystery.  The logger pings ONCE, when the details are loaded.  If I interact with it or change anything, the details do not change.  Even if I change items, the inital state does not move.

            However, if I close the Item Details window and then re-open it, I do get a ping.  

        -befoe I do, potential solve.  I could track which item is active in a higher state.  brb.  

        -I was able to do it with UseEffect, and setting the local state to match the item's Returns disposition after every re-render.  A couple problems with this.

            -First, the input field behaves weirdly.  It doesn't leave the old value if I enter something invalid.  It just clears the whole field, although the error message does display what I should have done instead.  AFAICT this is because since I am referencing the session item's dispos when I set the local state, I have to include the session item as a dependency.  I don't understand why but that is the rule.

            -Second, React's docmentation recommends against this.  I'm setting the same state twice, once in the inital render and again once the render is complete.  

            -The third reason is that the only reason I have a local state tracking the input is so they can have an invalid number.  If I feel like I don't need that, I should get rid of tracking dispositions in the local state entirely and have the whole thing track the global state.  

        -Second partial solve: just do the whole thing in the global state, don't allow any invalid numbers.  Not the IDEAL user experience, but it's no worse than using UseEffect and the logic is simpler.

        -Third option:  If I provide each item with a unique Key prop (like if I was mapping from an array) then it will trigger a re-render each time.  The problem with THAT is that my state appears to get re-set every time I re-render, so I keep having to click on the "Damaged / Defective" button each time.  

            -If I hate this and need to solve it, I could store which tab is active on the item in the sessionItems.  I don't think it's technically even all that bad because it doesn't have to get stored in the database.  It's just a property I add to the item as I create it.

            +The other plus to doing it that way is that I get to keep the Local State.  I'm doing the real-time validation with no submit button because I think that's the most user-friendly way to do this, but I have a feeling they're going to want the submit button and if I have to change my approach to use a Submit button I will absolutely need a local state.

            -Alternatively, I could just store whichever ItemDetail30 tab is active in ReturnsIndex.  It won't be item-specific but I honestly don't think that's a big deal.

        -Fourth Option:
            -I create an Active Item state in ReturnsIndex.  I'm actually already kind of tracking this.  BUT.  Here's a huge problem.  I was assuming that changing the active item would trigger a re-render, but it doesn't right now.  OK, nvm this is nothing.  

    4:20.  OK.  That actually wasn't too bad.  I learned a few cool new tricks and got the dispositions displaying correctly.

        -I'm not really ready to dig into the Matching.  I think that's a task for tomorrow.  I think today would be better spent doing some other cleanup.

            -Moved to 9 Jan.

    5:00 - nvm, I think I'm actually done for the day.  Just don't feel very smart right now and it's probably because I haven't eaten.  Instead I'm going to think about how to handle unwanted dispositions.

        -Something I've been wondering for a while is if I even need to be tracking dispositions in matching.  The only quantities Matching cares about are Unwanted or Damaged.
            -Technically, some other process might care about how much we refunded a customer.  Maybe.  Or not?  Might be that all we care about is what invoice they came from?  
                -Actually, come to think of it, that shouldn't matter either because AFAICT we have no way of knowing what WE paid for a given unit.  If the SKU is the same, they're indistinguishable.  So the price Lowe's paid per item is meaningless.  

            -Someone in our process might still need a count of how many came in of each type, but I really can't see that mattering in Returns.

            -The other point is that from my POV, only the Unwanted and Damaged totals matter for the refund.  Like, I'm already capturing this info.  

            -Now, the other thing I have wondered:  Do I just jam all the dispositions into one Dispositions object, or do I keep them separate?

            -Jamming them all together makes it a little easier to loop through.

7 Jan 2023
    -11:00.  Got kind of a late start today although I don't recall wasting a lot of time.

    -First order of business:  Figure out what to do with the Unwanted vs Damaged dispositions.
        -I've realized that the reason I'm hesitant to commit to doing them all in one big object is because having them separate is more future-proof.  If I separate them it's hard to imagine a future scenario where I wish I'd done it different.

        -I still feel some doubt.  I'm very clearly doing this because it is easier.  However, this does keep the code simple-ish.  I'm already afraid to mess with Matching because of its complexity, although maybe I shouldn't be.  

    -I still think I'm going to use one big dispos object.  This is a VERY secondary feature, especially when it comes to matching.  Remember Rule 1.  With that said, I will need:
        -An object of Damaged conditions.  I'm going to check for Damaged conditions because I don't expect them to change and then adding future objects will be easier.  

        -Change the evaluation in the cost assignment portion.  Instead of just checking for Unwanted, I'm going to check for ALL Damaged types.  
    
    12:00 - OK, that went pretty smoothly.  
        -The next hard thing I need to do is to figure out what data I need to be consuming in the Process Payment phase.  Started doing this on the work Mac but I really prefer this keyboard.
        
        -Refunded Items:
            LI:
                -Item Details.  I guess I could get these from the context or from the ScannedItem list?
                -Per-Unit price: this will be in the MatchBite
                -Quantity: MatchBite, but may need further refined.

            Data Translation:
                -I could do it by MatchBite, which is basically the same as doing it by Invoice.
                -IF I wanted, I could loop through the list of MatchBites and combine any that share an itemNum and a price, although that might be overkill.
                -Alternatively, I could merge ONLY on the basis of itemNum and average the price, but is that good?  It won't be clear that the 'price' is a derivation and if the customer sees a price that isn't on any of the invoices they might assume fuckery.  I think if I'm gonna combine items I should either leave out the unit price or make it explicitly say "Mulitple Prices"

        -TotalReview:
            LI: 
                -Total Refunded per tender type
                -Original Tender
            
            Data Translation:

                -AFAICT I need to make a new structure for this.  I would need to loop through all the MatchBites, loop through each bite's payment method, see if it is unique, and then either add it to the list or to the type it matches.

                    -I'm thinking about changing the items in the database to include an Identifier property (replacing things like CCnum or check numbers).  If I do that, my loop gets a little simpler.

                    -The case against would be that I think I already need to do some payment-type-specific behavior to get the string I will use to describe it in the output, so I might as well just do it there?  And also the Refund to Tender type is gonna need some conditional logic?  Yeah, I don't think I need to change it.

        -Modified Invoices:
            -In each MatchBite, I am currently not handling payment.  Once I complete the Sum function for the invoices in the Store, each invoice will have a Payment object that reflects how much was paid for that type.  
            
            -Once I have calculated the total money for each Dispo, I should deduct that from the Prices.  

    2:15

        I've updated the MatchMaker to include a refundPerPayment{} object, to loop through the Invoice's payments and deduct the adjusted price of the matching disposition from those payments, and to include the amount deducted from each payment in the refundPerPayment{} object.  In theory, the rest of the Matchmaker hasn't changed so this should be OK?

            -It's now ocurring to me that there's no reason for this to be happening in the Dispositions loop.  This is per invoice, so I could easily do it in the Invoices loop but after this loop finishes.  In fact, I think that's what I will do.  However, I can't even test what I have until I get the function for total prices in the Invoice Context working.  From what price would I be deducting?

            -Still, I think this was a mistake.  It's computationally less efficient to be doing this operation for every match, and it's not even more readable. It ought to live with the Invoice it's happening to. When I swalk today I should give some thought to how I made this mistake and how it could be avoided.

        -I need to do the function that totals up the payments in the Invoices.  I guess I could just do it by hand, but that's bad if I ever change anything and also no real coder would choose that.

    -4:30.  A fun new twist.  Apparently, Javascript can't always represent decimals accurately, and I think I finally understand why.  Any integer is easy to represent in binary.  But decimals must be represented fractions of two binary integers, and sometimes those are decimals are really long, or even infinite, like how 1/3 = 0.33333 .  To solve this, JS will round a number off at some point.  

        -The solution I have found looks hacky, but I saw it recommended in several places so I think I'm gonna do it.  You represent money as the total of cents rather than the total of dollars, and then just n/100 right before you show it anywhere in the interface.

        -The other thing I could do is just Math.floor() any of my divisions, but I could still have problems since I still have decimals all over the app.  OK, guess that settles it.  Cents it is.

        -Ha.  No matter what, today is pretty cool.  I finally, clearly understand something that always confused me before :)

        -I guess I can still use the restock fee rate, but I have to remember to Math.floor whenever I do.  

    5:35
        Looks like there are some issues with the Invoice Adjuster although the rest of Matchmaker appears to have survived intact.  Instead of debugging them I am just going to move this loop out of the Dispositions loop like I was planning.

        OK, ran into another problem.  It looks like on the 200 / BBB match, the matchmaker looped a second time and added an empty matchbite, which shouldn't happen.  If there are no unmatched items of 200 left, the loop needs to go to the next item.

        Come to think of it, I think the second MatchBite was from a different invoice.

    6:45
        Well, I didn't do what I said I was going to do (eat) and now I'm feeling dumb and out of gas.

        I'm gonna swallk.  I have a good place to start tomorrow.  I kind of whiffed today but I actually think this went pretty well.  I'm happy with the decision to include everything needed for the last two hard screen in the MatchMaker.  When I start again, I need to:
            -Do BBB / 200 and see if I can reproduce the error.
            -No matter what I find, I need to come up with a more organized way to handle my conditions in MatchMaker, and I think it's having all my -continues- at the start of the loop and my -breaks- at the end. 
                -Continue means: Keep looping at this next level, but on the next item.
                -Break means: Stop looping at this level.

                Or, if we have:
                    for (const i in Array){}
                
                -Continue is: don't continue to process 'i'
                -Break is: Don't continue to process 'Array'

8 Dec 2023
    -OK.  I'm nervous but also excited.  If I can get this up and running, the road really should be clear ahead to make the rest of the app.
        -Find out what exactly the error was.
        -Step through the app and make predictions.  This was a pretty clear error and we should be able to identify where it's happening.
        -Now, the exiting part :)  I really liked my description of the Break / Continue Statements.  I'm hoping that with this better understanding, I can rationalize the app.  
        -I wouldn't mind seeing if I could get all Unwanted assignment happening in the ItemDetails30 panel.  
        -MatchMaker is just so complex that anything I can take out of it helps me.  

        -While looking up what to call Break and Continue (they are statements) I found something else cool.  AFACIT all statements can be given a label in the format of labelName : statement.  A Break statement can accept a label as a argument (?) by writing    break labelName  .  If you don't specify a label name, the break statement terminates execution of the current statement or loop and transfers control to whatever is next in the script.  However, you can break out of a higher loop as well.  Just specify the name, and break will break to that level. 

    11:30
        -Ok, the error looks like somehow we deducted the same amount from Check and Credit Card in the BBB invoice, even though Check alone had more than enough to cover it.  
        
        -I think I see at least part of the problem.  Every time I loop through, I'm comparing the TOTAL amount being refunded from the MatchBite to the TOTAL paid for each payment.  Well, that total in the MatchBite never changes!  
        
        
        I think I need to clone that number and decrement it on every pass.

        -OK.  It APPEARS to be working now?  
        
        -This thing is getting so complicated :(  And I think that's part of why I still haven't fully engaged, because I'm not sure how to make it better.  Or, actually, I think my problem is that at this point there is so much going on, I don't know how to test that it is working properly.  OK.  Two things I feel like I can do.  

            -I should make a map of the ideal fractal for the MatchMaker.

                loopLabel: (for i in Array){
                    - vars of routes to any data being processed. (1st b/c these can be handy when checking skip conditions)

                    - conditions for skipping this iterator

                    - Unfilled output that this cycle of the loop is building

                    - steps: (as many instances as needed)
                        -process, store key data into variables
                        -increment the output.
                        -decrement the inputs
                        -clean out empties.

                    - Send the now-fully-built output to its parent.

                    -Conditions for breaking from this loop.
                }

            -Go though Matchmaker and see what we could ditch.  
                -Do squeezing and Unwanted assignment within ItemEntry30?
                -I could ditch the disposition matching, but it's not a huge piece.
                -Would having all the refund details (tax, adjustments, etc.) life with the Refund-Per-Payment be worth anything?  

    1:45
        Still not super engaged.  I did eat, and I do need to remember to make commits as I go because if I make a lot of changes, it becomes harder to diagnose where  a problem is happening.
            X -Check and see if MatchMaker is working as-is.
            X -Finish re-organizing on the CoVID CDC pattern.
            X -See if I can't move those Break conditions to the end.
            -try to put all break checks into one If statement with || conditions.


            -Once that is all done, I need to figure out a way to have any payment-specific details (CCnum, Checking, etc.) included in the Match Bites because it's going to be needed.  
            -Look into doing all the squeezing in ItemDetail30.

    3:15: OK, found another error.  If there are multiple invoices containing the item and all the items are matched in the first invoice evaluated, the second invoice still gets evaluated and an empty MatchBite is pushed into the item's Array in Matched.
        -First, let me see if I can add a third invoice and see if that gets 2 empty MatchBites?
            -It does.  

        -My hypothesis is that my break condition of !cartItem is not evaluating as I expect and that's why it continues to loop after completing the match.
        -OK, hypothesis confirmed. the cartItem variable is showing a full clone of 100, with quantity set to 0.  The reason I am confused is that unmatched_items{} is showing an empty object.  I THOUGHT that the variable was a pointer to this item within unmatched_items, but it looks like it's a clone?

        OK!  Another breakthrough, I think.  I was operating on this seemingly-dumb but seems-to-work heuristic of: if I'm going to delete a property and I'm using a variable to store a path to it, MAKE SURE that I've got at least ONE additional segment to that property's route.  Well, I finally found out why that is!  I've been wondering for a while why, for this example:
 
            const test = {
                L1:{ 
                    L2:2
                }
            }

            const pointer = test.L1

            delete pointer.L2               // works fine
            delete pointer                  // don't do shit
            const eureka = delete pointer   // eureka = false;

        Here's the secret.  The 'delete' operator returns a boolean based on what it did.  If I delete an object property, even if that property doesn't exist in the object, 'delete' returns true.  Otherwise, it returns false.  

        And eureka holds the answer.  It's not working because JS sees me as trying to delete the VARIABLE, not the property the variable points to.  At some point I should probably play around and figure out all of the specifics, but that is a cool find, and it explains both my result and my rough heuristic perfectly!

        I would also predict that if I'm performing operations, like:

            pointer.L2B = 3

        then it should work like you'd expect.  That variable still contains a pointer that I can operate on.  It should ONLY be 'delete' that has problems.

    5:45.  Finally finished re-organizing the Matchmaker, I gave it some moderate testing, and it appears to be working correctly.  I am so relieved.  I am just about out of gas and I want to be done, but I'd feel obligated to continue if I were seeing problems.

        -I feel great.  Like, legit, really good.  This was probably the hardest day I've had since figuring out how to do the matches in the first place, and I feel so much better about the Matchmaker now.  Yes, I didn't complete the work on it, but I got the hardest part done.  I was good about using hypotheses to diagnose problems.  I was able to see the pattern in such a way that I was FINALLY able to come up with a fractal organization template for the MatchMaker.  AND, I this weekend I figured out TWO things that I didn't understand at all - weird decimals in JS, and why having an extra route-segment after my object paths stored in variables seemed to make a difference.  

        -I still need to figure out how to include identifiers as tender types are matched, but that SHOULDN'T disrupt anything that's already working so I'm less worried.  If ever a day deserved a swallk, this one does.  

9 Jan 2022
    -First thing I would like to do today is figure out how to handle the payment-specific information.  
        -My first thought was that for all the payment types with unique information (Credit, Debit, Check ??) into an Identifier object.  If I did that, I'd have to make sure I update Search because Search uses this info.

        -However.  There might be an easier, dirtier(?) solution.  For each invoiceNum.invoiceDetails.payment[thisTenderType], I could just spread the entire contents of the existing object into the refundPerPayment{} obj in the matchBite.  I think that would capture everything.

        -Like, it's kind of weird but I don't think it costs me anything.  When I'm processing these into the Return To Tender array, I'm going to need to do conditional logic based on the type anyways.  An extra layer of organization doesn't really save me anything.  

    10:00.  Sweet.  That was easy.

    Next question.  The prices are definitely bugging me.  Two approaches are possible.
        -I could keep everything as cents and then divide everything /100 before consumption.

        -I could go back to using dollars.  I'm realizing that the dollars weren't really my problem.  The problem is that I wasn't rounding when doing division.  
            -Well, I suppose that's not correct either.  I guess I can't really round decimals?

        -OK, so.  Costs are consumed in:
            X -The bottom RefundTotal component.
            X -The SessionItems70 LIs
            X -MiniItem LI
            X -FullReview LI?
            X -SessionInvoices70

    3:35: I've finished the updates.  I also didn't take anything today so my focus is not great.  Kicking around the idea of doing some detail work and hitting the Refund to Tenders tomorrow when I'm a little more dialed in?

        -I would like the Selected Item to display a little blue inditactor to show that it is active.  

        -Figure out a more logical way for Input validation red warning messages to appear when needed.  Right now they are visible at the start and only go away when the user is entering.

        -After entering an item, ItemEntry30 should focus on the itemNum field instead of staying on the Qty field. oo

        X - Add RefundTotal into the StartScanning page.


10 Jan 2023
    the note I left myself from last night:
        
    4 outputs from matchmaker. 

    Well, why not?  Wouldn't it be nice if I didn't have to do any additional processing in the TotalReview?  It also makes sense because I'm also going to need that information in the next step, so I actually SHOULDN'T be storing it in Total Review.

    Buuuut - a problem.  How to handle situations where the the refund tender isn't the same as the original tender?  
        -It wouldn't be too hard to add a dispatch function that lets me change this object, but if for some reason I were to go back and add another item or invoice to the session, the RefundTenders object would be re-derived an any changes I'd made would be lost.

            -That's not actually the end of the world.  First, it's VERY rare case.  Second, it's annoying but I don't think it would cause errors because when the user does eventually come back, the program will run them through the same steps.

12 Jan 2022
    OK, got a little over an hour before the staff meeting starts so I am gonna do SOMETHING.
        -I could try and solve the problem of how to uniquely identify payment types, but tomorrow is looking pretty clear for me and that might be a better time to do it.  There's a good chance that whatever approach I try first might not work, and if I have to stop then I have to re-load the context into memory when I start again.

        -I think that what I will do instead is figure out how to make the blue bar appear on a selected LI.
            -Very first thing is to figure out what 30 panel the user goes to when they leave ItemDetail30.  OK, so it looks like it's ItemEntry30 in both cases.

        -OK.  Program removes active item when the ItemEntry30 panel is dispatched 

        -Now, how to indicate it?
            -Got a partial solve.  I've currently got a class that sets the left border to a visible color, and logic the TR mapper in Items that applies that class if it is selected.
            -I also added the same border but transparent to the whole table, which appears to work OK because I have border-collapse on?  (don't actually understand this)

            -The problem is that anything that's not contained within the table, like the "Coming Soon" indicator, does not have that border.  So my choices appear to be:
                -Leave it like it is and then remember to also apply the border to anything that goes inside.
                -Alternatively, I could create some kind of border component, put it inside my TRs and my TH, and then have some logic that activates it?
            -I THINK I prefer the second one?  I really want everything to stand on its own to the greatest degree possible and not impose requirements on outside components that I have to remember to apply.
            Right now, I think that's the way to go?

13 Jan 2022
    10:30.  Struggling to get started, but 42069 is finally underway, Kristin and Anthony are in a store together, I've made good progress to show at my paid work, and Sorin appears to be on the verge of settling down for a nap next to the desk.  I SHOULD be in the clear for the rest of today :)

    First thing to do is to see if I can add the marker to my TH and TRs.  Once I get that, I can try it and see how I feel about this approach vs. the border change?
        -OK, we got a problem.  The standard table does not include the indicator.  

        -Man, this border is turning out to be way harder than I was hoping.  
            -I was just about to write a long complaint about how it was really hard to do it with a component, but I'm now wondering if I can actually do it with a CSS class that I just apply to an empty <th> and <tr>s.  

        -OK, sweet.  Worked like a charm, got me everything I wanted.  Trick was to just store the stared details in the CSS classes without a component, and just apply the CSS to the <tr> and <th> directly.  

        -I do kind of wonder about these earlier components.  I wonder how many of them could be simplified and made mostly through CSS.  Rule 1, though.

    1:55:  Going to try to steer into the hardest problem right now, and that is how to handle the Tenders output.
        -At the moment, the approach that seems easiest is to add some kind of tenderKey property to each transaction type.
            -I'm wondering about making the TenderKeys as the primary key, but I think that's a trap.  I need to do certain action like Lookup on the basis of a more general type, like Checking acct and routing, or Credit Card numbers.  

        -Alternatively, I've also thought about moving all the unique identifiers into an  'identifier' property and then deriving it into whatever I need when I'm consuming it, but I don't think that's great either.
            -It doesn't really make search easier, because I'm pretty sure I still need to specifically define how to search on the basis of the payment type (I can't search for a CCnum the same way I search for a checking account and routing number)

        -OK.  I think what's bothering me is that I'm using   tenderKey   as a primary key, and it's really not.  I think that this is probably just a Rule 1 and move on.

        -Got it all working and feeling zero push right now.  Gonna call it a day.  It was actually pretty productive in terms of "problems no longer on my plate" but I did not feel very engaged and I do not feel like I did my best :/

14 Jan 2023
    -10:30, 42069 underway.  I didn't do my best yesterday.  Today I would like to feel good when I wrap up.  I've done a good job dodging time-wasters.  Now, I just need to cultivate my sitzfleisch and get it done.

    -One other thing.  I'm hesitant to over-emphasize this because I don't want the work to become unpleasant.  I'm also bearing in mind that one draws quickly by the choice of marks made, not by the speed of mark-making.  That said, I would like to try and move a little faster.  If I'm not sure what approach to take, I should be in here writing.  If I'm not sure where an error is occurring, I should be in the debugger.  And if I'm not sure what to do next, I should my choice should be the work with dependencies that I am MOST confident will be in the final product.  The only distraction that is always acceptable is Sorin.  

    -Let's just gently, continuously make good decisions today.  It's important.  We're so close to having this thing on the run.

    -First task:  
        -I was going to say that I want to do the input validation, but maybe that's not a good decision.  I don't actually know how it works in the live app.  I'm not at all confident that we can do real-time validation the way I currently am, so any work I put into this might be moot.  

    -OK, let's list what needs to be accomplished, what the blockers are, and how to address them.

        -I need to populate the ReturnedItems30 panel.
            -Blockers:
                -I need to make a decision on if I am going to combine MatchBites.  
                    -No combination.  
                        + easiest to do right now.  Shouldn't actually have THAT many price mismatches?
                    -Combine if itemNum and price match:
                        + Easier to read, probably best matches mental model of Redvest and shopper 
                    -Combine ONLY on itemNum. 
                        -NVM, I think this is stupid.

                -If I am going to combine MatchBites, I need to decide if I am doing it within the 30 panel.  If I am not, then I might need to rethink the output of the Matchmaker.  
                
            
        -I need to populate the TotalReview70 panel.
            Blockers:
                -I think these objects need to contain more data than just the tender type.
                    - Refund tender type
                    - What alternatives, if any, to the refund tender type?
                    - Did refund fail? (for basically anything except cash or merch card)
                -Where should these additional types be added? 
                    - If I do it in the Matchmaker, where should it be?  In the loop where refunds_by_tender is being populated?  Not the most efficient but I think it's the most readable?  


        -I need to populate the TenderTypes30 stepper panel.
            Blockers:
                -I need to know how to handle the alternative types.  Will it be in-panel buttons?  Will it just be the 'refund to cash' button in the FooterContainer?
                
    12:05: OK.  I think the smart thing to do right now would be to tackle the tender types.  First, I can do this without any input from Dave.  Second, I think I generally know what I want to do.  

        -Do I need to have a separate process to determine what refund tender options are available?  Well, I guess I should list some types and see?

            -I THINK that for any process that fails, the default is in-store credit with the option to refund as cash?

            -Credit: Should always be credit unless the process fails.  Then standard failure?

            -Cash: Should always be cash.

            -Store Credit: I THOUGHT it should  always be Store Credit, but in some recent work looks like there is a cash option?

            -Check: Refund to account, with option for cash?

            -Apple / PayPal: in kind unless failure?

        -OK. Based on this, I think I should probably have some kind of function that generates these outputs.  The next question would be where to do it?  
            -I could technically do it in the invoice-context.  I know nothing about data, but my guess would be that in a database, you should only store UNIQUE data.  Like, I don't think it would make sense to store the product info with the invoice because, for a given product number, the product info is always the same.  You just store the product number and get that from a different table when you need it.

            -I suppose that means I could generate the tenderLabel dynamically as well?  Might be a Rule 1 skip.  

    1:00:
        So it looks like where this is going is a revision to the Matchmaker.  At this point the MatchBites aren't really doing much.  My outputs are going to be:
            -A Refund Money object with total price, adjustments, etc.
            -A Matched Items object, with itemNum, price, and quantity.  IF prices match, 
            -A RefundTenders object with tender type, didFail, and alternatives if there are any.   
            -Unmatched and modified_invoices adjusted respectively.

        I do realize from the outside that this kind of rat-fucking looks like time-wasting, but I really do think this is right.
            -According to Dave and also my own intuition, this is the right way to do it.  The MatchMaker is absolutely central to the function of this application.  Like, if I was going to lose this entire project and I could only keep 2 files, I would choose Returns.js and the Matchmaker.

            -I've been wanting to refactor Matchmaker for a while.  I think I can streamline this thing.

            -I like the idea of doing as much processing as possible in as few locations as possible.  I think my design pattern is to do as much processing as possible as highly and as centrally as is practical.

        -The first thing to decide.  Local data or app data?
            -Local data:  
                -probably easier to de-bug, and I can use my local debugger which I really do prefer.
                -Not sure how much re-wiring I would need to do if I do the other way.  For this, I am certain it is zero.

            -Real data:
                -Right now, my resolve is strong. At 6:00, it won't be.  If I get this thing running in-context, then when I am done, I am done.  I won't have to worry about chasing gremlins in the system because that part will already be done.

    2:00 - Switched Returns to use new ReturnsMatchMaker.  Everything is working normally, which should be the case because I haven't changed anything, but I did want to check.

        - Now, another decision.  Do I want to keep looping through the dispositions, or do I want to just group them into Damaged / Unwanted?

            - Right now, I'm kind of leaning towards keeping the dispositions.  When it comes time to add Unwanted Dispositions in the future, I can look at separating them and refactoring the Dispos loop, but I don't really think they're hurting anything for the time being and that's one less chunk of refactoring work for me to do.  

        - The first thing to do will be to put together a MoneyObj.  Once I've got that, then I will connect that to the ReturnTotal component.

        -Once I get the RefundMoney obj, then I will get rid of MatchBites.  I don't think anything else is using that, and the errors will guide me on what to fix.  

    3:30:
        - Got the money displaying correctly in the RefundTotal component.  

        -I now need to figure out how to handle refunds_by_tender without the MatchBite, because I think I'm currently referencing it?

        -Well, it looks like I'm at least going to need some kind of per InvoItem money accumulator

    5:10:
        I'm not doing well.  I'm not super focused on the work and I don't really want to be sitting here right now.  I'm going to try and catch one last wave and finish strong.  I'm actually not doing too bad, progress-wise.  Let's just make decisions we can be proud of for another 90 minutes and then if we want to stop we can stop.

        -First, I'm going to clean out anything related to MatchBites.  I shouldn't need it anymore.

        -Next, I'm going to populate the MatchedItems.  I need a few bits and bobs of date about the item, but I should be able to grab that from the unmatchedItems.

        -Finally, I should write an empty program to populate the refunds_by_tender.  It's OK if it isn't perfect.  It's actually OK if it doesn't do anything other than return the input because I can always fill more of it out later.

        -
15 Jan 2022:
    12:10.  IDK wht, but it always seems like a trip to the gym causes me to spend at least an hour screwing around before I start programming.  Here's where we sit for today.

        X - I feel like I'm most of the way through populating MatchedItems.  I just need to stop being a weener, deepClone each item object in the Items loop, and then spread its value into the new ItemObj.  

        X - Then I need to do some tests to make sure everything is working as planned.

        X -After that, I need to at least put in a function to populate refunds_by_tender.  I can either populate it or move on.  
            -spinning wheels because not sure what to do.  

            -OK.  The TenderTypes loop uses keys, which I would want anyways.  So I have a string of the key name, and if I want I could get the values out.  

            -I think the thing to do would be to write the Tenderizer to take 2 arguments, the key name and then the value of the object.  I'll use the key in a Switch statement and then any additional processing can use the value.

    1:50
        -OK.  Am I done?  The tenderizer() is now in the Matchmaker, and reading and outputting something.  

        -First, I'm going to eat.  That's an easy Good Decision.  Then I will figure out what to do next.

    2:40
        -Heh.  Let's try this again.  What next?

        -I could create the TotalReview page.  Like, that's the obvious answer.  I have the data to populate it, I KNOW it needs to happen, and it gets me one step closer to having something I can show.  Why am I hesitating?
            -I think there's some level of fear now that the end is in sight.  This has been basically my whole life since I broke up with Kim, and as long as I have this I don't have to answer the question of "What next?"
            -I guess I need to remind myself that there is still PLENTY to do in this app, and that as long as I am working in Returns there will always be new features to build.  
            -In fact, the sooner I can get this to MVP level, the sooner I can start openly working on it on company time.
            -Also remember the deal I made myself - if I complete this, I can buy a fancy watch :)
            
        X-First, it looks like we've got a bug.  If there are no items missing invoices, we should skip the second review.  

        -And a second bug: the FirstReview section should be scrollable for overflow.
            X -I'm just gonna do this before I forget about it.

    4:30
        OK, looks like another bug.  My ItemCoder seems to be having trouble picking out special categories.  It didn't come up before because AFAICT the very first condition it checks is if the status is 'preSearch' and that was always true.

        Fixed.  

    5:00
        Coming up on time right now.  I could actually REALLY go for a swalk, but I got a date in about 90 minutes and that's probably a bad idea.

        I think I'm going to try to just populate the cash totals and call it a day.

        Eh.  Found another bug.  Looks like the restocking fee isn't being applied to SOS items?  

        HA!  Got it.  Looks like the MatchMaker is working fine.  After all, the RefundTotal amounts are correct.  But I am populating the matched_items object with the price paid from the original invoice, which DOES NOT count the restocking fee.  OK, that fix is easy enough.  
        
        Well.  Or is it?  If some items are damaged and some are not, those fees could be different.  Shit.  OK, I might need to calculate this inside the Dispos loop?

17 Jan 2023
    -OK.  First, I need to create a function that creates list items to populate the Tenders list.

    -The next challenge after that is probably to figure out what to do for the final list screen and adjust the Tenderizer accordingly.  The Tenderizer needs to:

        -Provide a return tender type based on what the original tender was.
        -I need some kind of option to see All Smooth vs. All Fail.  ATM I think maybe a small or hidden button at some common catchpoint (RefundTotal?  Maybe back at Actions30?) because it would be kind of nice to use the existing cart contents and not make the tester populate the whole thing from scratch.  
        -In the case of failure, I need to specify what alternative refund tenders are provided based on the tender type

    -After that, I'll need to create a component for the stepper, which AFAICT doesn't contain anything I don't know how to do but will definitely take some doing.  

    -I will also need to create a 70-panel that presents different return types based on what alternatives are present in each refunds_by_tender type.

    -The FailMode is proving more challenging than I expected.
        -Right now, I think what I ought to do is create a global Scenarios state, probably in Actions.  I think I also want to make it changeable through the interface rather than the code because I won't necessarily be the only person running tests.  

        -Well.  I'm kind of spinning wheels right here but I am pretty confident that I'm going to need a different page and a link to get there.

        -Or maybe I don't.  Since I don't actually know that it is needed, I could just do it in code and save some time?

        -OK, so what I think I will do is specify WHAT to do in the case of failure within the Tenderizer, but store whether or not to do the failure scenario in the State.

18 Jan 2023
    Well, I've been performing like shit all day, but I've finally caught a burst of energy and, naturally, I don't want to spend it on my real job :p  Let's do this right.  69420 and then try and jam till about 7:00.  Damn, I'm like... fidgety right now...

    - I think the first thing is to at least get the Tenderizer returning the Original Tender and Return Tender types based on the input type. Actually, never mind.  I'm ONLY going to do the Refund Tender.  Creating the Original Tender string just from the Tender obj would be nice but it doesn't have any dependencies.  

    So the obj for each tender needs to include:
        - User's choice refund options.
        - A string describing refund options?
        - Options in case of failure (is this every anything besides cash + store credit?)
        - Maybe a canFail property?  Or maybe this just tracks if the failureOptions property is empty?

        -Part of me is wondering if I shouldn't just have absolutely everything relating to tenders in a big old object?  

        -OK, here's what I will do.  I'm going to at least try making a big tenderStandard object in Returns/Functions.  I will at least use it in the Tenderizer and maybe other places too?  
            -I guess the problem I am considering is that in the Invoices store, in some of the search functions, in the MatchMaker, and in the Tenderizer I am calling dealing with the same name in a bunch of different contexts, having the right name is necessary for this to work, and I worry maybe I am violating DRY?  

            -I don't think this is necessary to get to the end, so maybe I should drop it.  I just know so little about Javascript that I don't know if I'm doing bad.  

    Crap. Now that I'm thinking about it, I might need, or at least want, to do some backtracking.

20 Jan, 2023
    This 69420 might be more of a 69-24.  I need to write as clearly and specifically about what it is I plan to do and why because I could see big waste either  way.  Either I waste 2(+?) days on something that might be completely unnecessary or I move ahead, spending time on work that I later have to spend more time uprooting and working around.  

    -OK.  So can I even describe what problem I am trying to solve?  I guess my original complaint was that I have a bunch of references to different tender methods scattered around the app, but no SSoT.  
        -Transaction details [card specifics, amount spent in Store]
        -Description string doesn't yet have a home (either Tenderizer or central Tenders object?)
        -User options and error-handling options both still TBD.
        -Primary Key - currently being explicityly declared in the Store but it would be neater just to have it in one place.  

    -I think my original objection came from the fact that for the Lookup feature, I was having to copy/paste a bunch of invoice properties at once and that seemed clunky, but most of the lookup types are not payment properties so even if I did have some really clean, perfect reference object it would, at best, solve that problem partially.

    --Aaaaaand, Lina just told me she's moving to Pittsburgh.  Fuuuuuuuuuck.  Now I can't focus AND I'm sad :(
    -OK.  That decision is done and worrying about it changes nothing.  Let's at least try to power through and get something done today.

    -So if I do make a perfect factory function, what would I get?
        -I don't think the MatchMaker would change much?  I guess I would be making the tender-label in the factory function, so a little bit?  (NVM, that's the itemNum and price, no name is made for the tender)
        -I would probably be storing derivable information in the invoice, things like labels, truncated ccNums, etc. but if I want to have that information in a single place I am doing that anyways?  
        -I guess the other option would be to have ONLY unique info in the invoice (which is probably the 'correct' way) and then Tenderize it somewhere else.
    -The other thing I would like to do is to have unique payment types, like different credit card numbers and checking acct. numbers as the keys for payment types, although I don't actually have to do that.

    -The last factor to consider: factories appear to be pretty useful and it would be a good idea to get some practice with them, although it seems like classes are the thing I'm less familiar with and I don't think this would be a class?  

    -I guess the question of having the unique identifier as the key is a separate question.  What would have to change?
        -Maybe the lookup?  
            -OK, I think this could be done.  I would just change the search route to stop at the key, rather than a property.  
                -Or, actually, I think I would have the variable as part of the path, and I would just check to confirm that the number match is has the type of 'credit card'
            -Same for a check, afacit.
        
    -OK, now onto the real question - should I be working on any of this?
        -The EASIEST solution:
            -don't change anything with the primary keys.  At this moment, it isn't a problem that I only support one credit card num per invoice.

            -For the sake of practice, I probably should have a Tenderizer.  Some of the stuff, like 'what kinds of refund tenders do we offer' I shouldn't be assigning by hand anyways.

        -So then it sounds like the only real question is if I want to do the unique primary keys or not.  And I think the answer is yes?  I think I want that feature at some point, so I probably shouldn't be building dependencies on top of it.  Maybe not a huge amount of re-work, but probably for the best?

        -Not related to the work, but I just thought of a cool idea.  For fastest filtering, filters should be applied in order of "excludes the largest percentage of the search space"

        -So then I think I should create a separate branch, change the primary keys, confirm that everything is working, and then do the Tenderizer.  OK.  Let's make it happen.
            -I am expecting to make changes in:
                -The Invoices store
                -the InvoiceSearch function for any searches of a payment type
                -Confirm that the MatchMaker is working on the new types.
        -OK, the changes seem to be working.
            -First, check to see if I can get there with the shorter route.
        
        -Looks like we have a snag.  I don't know of an easy way to do a comparison to a property key (not value).  For all the other searches, I'm checking if a property matches the input, but for CC, debit, and check I don't have an easy way unless I also store the # as a property.  I thought about having a creditCard property that could have [n] potential numbers, but those also have to have unique keys so I'm really just moving the same problem one level deeper.

        -Unless I want to have a unique process for the unique property keys, I think I'm just kind of stuck duplicating the info.

        -Also.  For what I'm trying to do, this is really a non-problem.  It's an extra property.  It's fine.  Let's Rule 1 and move on.  

    -The next question is how to handle the Tenderizer.  I was previously doing it as a switch statement, but since I'm going to have to do comparison in addition to just the key name, maybe just some if statements is better.

    -OK, found another bug.  Looks like I'm not finding a proID number.  I'm gonna call it a day and pick up here tomorrow.  To Do:
        -Figure out why proID isn't working
        -Change Tenderizer to If statements and then get it working.

21 Jan 2023
    Got a  date at 7:00 so I can't go all day.  Need to try and be efficient with the time I have.  Also slept like shit last night :/  Let's try and make good decisions here.  Tasks for the day.

    X -Figure out why ProID isn't working (or, conversely, why LCA is working.  )  OK, got it.  In the searchRoutes object, I had a key that didn't match what the button was dispatching.
    X -A brief feline interruption
    - Fix the Continue button on the second Review screen.  Not stricly necessary but it's annoying and it comes up way too much when I am showing this to people.
        -For this to happen, I think I need a basic, blank screen in the shared components.  
    X - relocate most of the shared components into subfolders

    1:40
        Actually not sure how I am doing.  I've been working pretty well, but I've been doing mostly peripheral stuff.  I created some new button classes to control button width from the App CSS classes which will improve consistency, but that's not exactly critical.

        OK.  The next thing to get after is the Tenderizer.  Once I can correctly populate all my refund tenders with the appropriate data, I can make the stepper and hopefully it won't be too hard.

            -Now.  I'm contemplating doing something MAYBE stupid.  The Tenderizer will be pure Javascript.  However, I'm wondering if I could make it as a React component.

            -OK.  After doing a little bit of digging, it sounds like the way to do this is with a Custom Hook.  I don't really even understand non-custom hooks, so I'm not sure how to proceed.

            -Custom hooks appear to be the correct way to share logic between components.  AFAICT the other big advantage is that they don't violate the Rule of Hooks.  

            -The problem I ran into with the MatchMaker is that it is just a plain old regular function, so it can't use hooks inside of it.  

            -I tried making a custom test hook to put into the reducer and got an error for violating the Rule of Hooks.

        -Let's get some more thoughts down on paper.  
            -I don't need to have the Matchmaker in a separate component.  It's not being reused anywhere.  I just want it as a module so the code isn't super long.

            -I WANT to have access to the Returns state within the Tenderizer, although I don't actually think that's necessary.  Actually, I'm not even sure it's good.  The Tenderizer should control WHAT options are available in case of a failure.  Whether or not it has actually failed isn't determined until later.  The individual stepper LIs are going to get their failure status from somewhere else, probably the 30 panel that controls them, and it will be easy to have THAT component see the scenario state.

        -OK, let's take a quick swalk break.  When I get back, I need to start writing the Tenderizer with its conditions.  

    4:10 - feeling pretty good, although this ~2 hours after dose 2 is when I'm at peak Adderall effect :)  

        -OK, got another bug.  The InvoiceSearch isn't finding debit numbers because I don't have a route to search for debit.  
            -I THINK I can just use a ?? on the creditCard condition to get it to search for debit?  
        -OK, it's working now.
        -At some point I might need to handle a check that's too fresh, but that's probably a problem for Future Me.

    -Gotta think here.  In the no-failure scenario, what has multiple refund options?
        -Debit: Original Debit or cash
        -Check: Original Checking acct. or cash.

    And in the case of failure:
        -Debit: SC or cash
        -Credit: SC or cash
        -Check: SC or cash
        -Digital: SC or cash

    AFAIK, store credit and cash can't fail?  I don't think I will ever need the 

    So I think the logic goes:
        If no user option, no Ask 1.
            If failure, Ask 1 (Fail Choice)
        If user option, ask for choice on 70-panel
            If failure, get user input before proceeding to next.

        -This also means that in the Tenderizer I need to create properties that hold user choices?  


    -It's getting near the end of the day.  I'm probably not going to program any more, but I do feel like trying to plan out some of the logic for the stepper.

    -Since both panels are referring to a shared state, I'll either want to track that state in the page instead of the components.  
    -Actually, I can probably just handle all the state changes in 
    session.refunds_by_tender.
        -If I do that, I'll definitely need a dispatch type to handle it.  My plan before was to have lots of logic in the state setter, 
    -I'll probably need some sort of logic to order the states.  I think I want the auto-complete options done first, followed by the ones with user input, followed by check.  
        -I was thinking I'd like that in the Matchmaker, but it's an object and I want it to be an object.

    -I also need some way of adding new tender types to the queue, specifically cash and store credit.  THAT means I probably need access to the Tenderizer here, too?  

22 Jan, 2023
    12:00:
        It feels like a very simple effort to get started but I tried to start 20 minutes ago and failed.  OK.  Let's get after it, and as a show of seriousness, we will start with the full 69420.

    - Probably going to start with some more writing.  I feel like there's a much neater, cleaner version of the structure I have in mind.

    - Actually, for my 20, I might start with the blank page, along with a dummy data object.  I DO NOT want to test this by going through all the steps I would need to to get 5+ matched tender types into this thing.  I'll get all the visuals and then confirm that it is working.  
        -IDK why, but I like this approach.  I know you're 'supposed' to have a plan before you build, but I want to have something on the screen to look at and I also think this will be a nice launch in to the work.  

    1:40
        I'm slowly getting into the work.  Still not super focused, but I want to try an experiment where I just jam as hard as I can for an hour.  Like, really try to drive through and be intentional with my focus.

        -I do think I at least have the skeleton I need to proceed with the work.  

        -I need to come up with a plan for the LIs.  They are going to have quite a few different states.  Active, inactive, complete, whether or not to display the second option, etc.  There are a few tricky things about this situation.  
            -First, the status of the LIs is going to be handled entirely through logic coming from somewhere else.
            -Also, they are going to be handled sequentially.  
        -OK.  So what I think needs to happen is that all the conditional display will happen within the LI, but the condition-setting will happen in the parent?
            -I don't even think I need a state in the LIs?  I think I probably just track all potential conditions in the new object returned by the Tenderizer?
        -In the FinalizeRefund component, I am also not sure I need a separate state?  My goal should be to handle everything from the session.refunds_by_tender state.  So let's think about what states to track in each tender obj. returned by the Tenderizer.

            For all:

                -processStatus:
                    "notStarted"
                    "inProgress"
                    "Complete"
                    "Failure"

                -secondChoice:
                    true/false?

            For potential failures: Check, Credit, Debit?

                -backup modes:
                    "cash"
                    "store credit"

            For tenders with initial user choice: Check, Debit?
                
                -refund original: true or false? 

            And I need to track the 70-panel content, although maybe that logic belongs in FinalizeRefund?

        And I gotta make these as universal as possible because the LI isn't going to know what it's dealing with in advance.  

        -I think I want to start by building Debit and Check, because their Sad Path is the hardest.  Once I've got those the others are easy.

        -I also need to think about how I'm going to handle the dispatches in Returns.  IDK if I can just have the dispatcher overrwrite the old content with new.  I guess what I could do is handle ALL the processing in Finalize Refund and then dispatch fully-prepared tender types to the Returns.session state?  Right now that seems like the best.

    2:50: 
        -small wrench in the plans.  There actually is at least one scenario where the LI hasn't failed but still needs to show 2 lines.  That is when there is a cash return, because we run them through a confirmation screen.  

        -Before I can verify that any of this is working, I think I need to have the LI component.  I'm gonna take the next 90 minutes to build the thing and then re-assess the rest of the day's plans after that.  

    4:00:
        -OK, kinda losing steam. If I can put up one last good session I will call it done for the day.  Let's go!

    5:00:
        -I just don't have much push right now.  I think I'm gonna take a a swallk and if I'm not feeling it when I get back, I'm done for the day.  

23 Jan 2023:
    2:50, just getting started.  I haven't pushed very well for a while.  The best result would have been to start a few hours ago, but the second best result is to make something out of the day I have left, so I will dangle a swalk in front of myself - if I honestly earn it.  That's going to include working until 6:00.
        -I will give myself a bit of grace here.  The stepper is a hard, complicated problem and just like the Matchmaker, I might have to pass through a rebus stage before I really grasp it.

        -I think a good rule of thumb is - data and logic should be stored in the lowest-possible parent of ALL processes that do (or will) consume it?  

        -So what that says to me is I want to keep the refunds_by_tender objects as lean as possible, and have as much of the logic as possible in the LI?  I probably could.  Tender-specific information needs to be stored in there, obviously.  I also think stuff like the String Name should be in the state because it's used in more than 1 place.  And I should track status, because I think the LI is only going to render based on what it sees?  

            -So I definitely need to track process status.  

            -The Level1 refund tender should never change, I don't think.  Like, if it's a debit card, what happens JUST to the L1 label?
                -If they confirm Debit:     No change
                -If they select Cash:       No change, add a Cash node.
                -If debit fails:            No change, add Cash/SC node.
            
            Yeah, I think that's right.  Now, for the second node: 
                -If failure:                No change, add Cash/SC node.
 
            And for L2 label, user selection:
                -If confirmed debit         No L2 at all.
                -If cash:                   Only shows cash.

            ALSO!  AFAICT, I think that only In-Progress and Warning states could ever have two lines.  Everything else should only be a one-liner.

            So the stepper should be able to figure out everything for itself if it can pull the following from Session state:
                -TenderType (determines what's available)
                -stepStatus: (determines most of what to render)
                -failureStatus: (also determines what to render)

        -So I think if I add in a tenderType: property in the invoices, I can get that from a single route into each refunds_by_tender{} object, and I can use it as a key to get specifics out of all the other objects? 
        
        -And where I'm leaning is to having some interlocking set of objects and using those three main properties as keys to get all the specifics.  Like, if there's a failure, there's a single choice: store credit or cash.

    -I do want to get started on this.  But I see an issue on the horizon, and that is the ordering of the tender types.  
        -Ok.  So I can't order the state, because it's an object and it should stay as an object because that makes it easier to add payment types.
        -I don't need to order it in the Review section because it doesn't matter.
        -So when I make the tendersArr in FinalizeRefund, maybe I just stick in a function that orders the array the way I want it and sticks Store Credit and Cash at the end?
            -So like every time the page re-renders (including state changes, since that's when I would be adding Cash or SC tenders) I'd get a fresh array where each element has identical properties to the state object they came from.
            -Sounds good, my only question is whether the array's order could change.  I don't think so, but if it did, that would be pretty bad.  I don't think it would (and Rule 1) but could be a problem.

    4:45
        Well, against all odds I am kind of in a groove.  I really ought to refactor the Tenderizer but I'm not planning to go much later than 6:00.  That work *should* be easy so I'm gonna postpone it to get more focus time on the TenderTypesLI.
    5:30
        OK, crunch time.  I am on track to earn a swalk but I've got to finish strong.  I actually think the correct play is to do those Tenderizer changes I was thinking about earlier because then I won't have to context-change to do it some other time.

    6:00 Aaaaaand, I did it!  Wrapped up with just seconds to spare on my timer.  I should remember today.  Even with a bad start, this kind of finish is possible.  Swalk earned :)

24 Jan 2022
    12:20
        The reason we got into trouble yesteray was because we didn't turn into the work as early as possible.  My work for today is done.  I'm clear until Design & Conquer at 3:00.  

        The first thing I need to do is make sure I've got everything I need downloaded for the remote doctor call today.  That's the single most important thing on my plate and I don't want to be scrambling at the last minute.  

    12:50
        OK, I'm in the clear.  Still did a little time-wasting but I'm in the game and ready to play.

        -I can start 69420 by adding in the second rows and creating the rest of the icons.  

        -I think I need to also store some kind of property related to the second row.  AFAICT it's only ever going to be Cash or Store Credit, but I don't think it can be purely derived because the user can make a choice.

        -I need to start thinking about the objects that will store all my status-related properties and how I want to organize them.  The goal should be to populate the whole LI just based on the tender object's properties.  I'd really like to have as little logic as possible.

        -I'm also going to have to figure out how to do the text styling in the stepper.  I really don't want to have a lot of different branching conditions for when to display boldness and black vs. grey text.  I'm thinking either constant weights and only vary color, or else Active is black and bold, and anything else is grey and regular weight.  I think probably the first option since the different weights do help tell everything apart?

    1:50:
        A little bit stuck here.  IF I hand-code the second row I'm kind of violating DRY, but I just don't want to deal with it.

    2:50:
        TenderType row is now correctly showing and I think I might be done for the day.  DAS is in ten minutes, then I have my surgeon call, then I have UX Refinement, and I don't think I'm getting back into the groove afterwards.

25 Jan 2023:
    12:10
        I was actually planning not to program today, looking at a drug holiday to reset my tolerance.  However, the rest of today is completely clear and with my upcoming surgery it's not like I'm going to be doing a lot of programming the next few days.

        -Also got a haircut and a vehicle inspection and registered Tango today so I'm actually kind of kicking ass.   

        -intersecting objects

        -That's what I wrote before I started 69420 because that's what I think the solution is. The heart of this is going to be states that track status, and for statuses shared in more than one they will pull in statuses.  

            -I need to build objects for each of the main statuses.  
            -I actually don't think I need to track Failure in the objects?  All dispatching is going to occurr in FinalizeRefund, so I don't think the LI needs to be aware of failure?

        -I think what I will do in FinalizeRefund is to have a state that tracks index.  It will cycle through each tender type (by index) and dispatch state changes to the session.refunds_by_tender object based on conditions and inputs.  
            -and I think the index of the key is the only thing I need to track to get through the list?  The cycle in FinalizeRefund will not directly affect the UI in any way.  It's just making changes to tender objects and TenderTypesLI is conditionally rendering.  

        -Spinning wheels a little bit, but I know no matter what I'm going to need a Condition object, so that's where I'll start.

        -Actually, got a better place to start.  First, of the tender objects are going to need some common properties, so I will add the ability to add those.  
    
    3:30.  Got interrupted by a surprise meeting.  I will set a goal of 60 and 90 more minutes and if I can pull it off I earn a swalk.  

        -OK, so where are we?  I think I'm tracking all the props I need to in the Tenderizer, so I should get started on the status objects.

    4:30:
        A few more delays, mostly related to my real job -_- but I'm still pretty dialed in and finally making progress! Two new tasks for the day:

        -I need to make a decision on how I am going to display the Active item and figure out how to conditionally apply the CSS in a way that isn't an incomprehensible hairball.
            -Yesterday I was thinking about having all the font weights stay constant and only vary the colors.  So what I will do is create 2 different classes, store the name of the class to apply in the Conditions object, and then have each element reference whatever style is associated with its condition.  SHOULD be pretty easy?

        -There's a third factor here, which is new from today.  When the tender type is changing or has changed, I need to strike through the discarded number (Looks like we shouldn't zero it out)

        -I need to figure out how tenderType and the status object interact.

    5:45:
        -Didn't get to the status/tenderType interaction, but the Conditions are working well in the TenderTypesLI and I'm gonna call it a day a little early.  Swalk has been earned and it's probably my only walk of any kind for a while :/

2 Feb 2023

    3:50 * First time back here afer my knee surgery.  Gonna try and get this back into memory.  I was kind of hoping to clear out all my real work today and do this tomorrow but I'm still waiting on a ticket.  I mean, I guess I could try and do it anyways, but I'm not super clear on what needs to happen.  I'm also frustrated and angry because I think the direction we chose just blows and I don't want to do it.  Just gonna write for a bit to jog my memory.

    -IIRC, I had all the different statuses.  

    4:30

    Got a bit of minor cleanup in.  Gonna try and jam for 90 minutes and then call it a day.  And it's OK if there's a lot more word writing than code writing.

    -OK.  So what do I need to do before I can proceed?  The LIs now display appropriately based on statuses.  I have a dummy list of tenders because until this thing is working I'm not going to spend the 5 minutes to add real invoice matches every time.

    -In my dummy list, I'm using the Tenderizer so everything is starting with the condition of Not Started.

    -IIRC, I'm going to be reading EVERYTHING from the session.refunds_by_tender state.  I THINK I don't even need a local state for this.  Everything I see in both the 30 and 70 panels should be dicatated purely by the status of refunds_by_tender.  
    
    -So maybe the first thing I should do is populate that state with the dummy tenders and read from there now?  It will save me some re-wiring later.  Plus, I need to be dispatching changes and as a static dumb object, that can't happen.

    -Maybe that will be my goal for the day.  Populate the state, read from the state, have a dispatch switch case to change the state, and call it a day?

        X -First I need to check the Matchmaker and verify I'm not screwing anything up.  
            -I don't think I'll screw anything up.

        X - Read the refunds_by_tender state from Returns and populate Tender Types 30 panel with it.

        X-Figure out how to handle the dispatcher
            -I'm leaning towards a really simple function where I just replace ALL of refunds_by_tender with a new state for each modification.  That should allow me to keep the logic simple 

    5:40
        Not the best day I've ever had but despite a late start I managed to get some valuable work in.

3 Feb 2023

    4:00 --
    
    Been kind of time-wasty today but trying to have a nice strong finish like yesterday.  Gonna go till 6:00 plus however long I feel like after that.
    
    OK, where do we stand?  
        -I need a way to get all of the tender types in the correct sequence.  I would like the automatic transactions to happen first, but I NEED the last two to be Store Credit and Cash, respectively.  

        -The other key factor is whatever order I sort the non SC+$ properties into, I NEED to make sure it's the same every time.  
        
            -What I wish is for them to be ordered within the object at which point I could just turn it into an array (since AFAICT for strings the array order is the insertion order)

            -I actually can't quite articulate why I want this.  I'm afraid of the order getting messed up if I add $ or SC in the process, which I am VERY likely to be doing.
    
        -The other option is to just sort the array.  I guess that isn't terrible, as long as I make sure that if I add SC + $ to the state and not just the array.  
            -Right now, I think that's what I should do.  I don't have an easy way to control the order the refund tenders are placed into the object, since they're being matched in the order they are found.

            -I think that no matter what, I need to write a function that sorts an array.  Even if I do want the object sorted, the only way that could happen is to turn it into an array, sort the array, and then turn it back into an object so there's basically no chance this function is a waste.  OK.  Looks like we have a direction.

4 Feb 2023
    9:55 IDK why it's ALWAYS so tempting to skip 69420, but I rarely regret it.

    -This 20 might be mostly writing.  

        X -The container for the steppers needs to scroll.  Probably a low priority, but also easy?

        X-I need a state to track the active index in FinalizeRefund.  

        X-I specifically need to figure out how I am going to handle the L2 steps.  
            -I think what needs to happen is that for any tender type that can display an L2, I need to have at least one property to store its value.

    I am now wondering if there is EVER a choice that needs to be made for a refund failure?  Like, if a credit card fails, we're not giving them cash, right?  

        -I think the thing to do is build the capability.  It will be easier for me to design for it and take it out than to not design it and put it in later, and I have at least one example of a choice being required on failure (Apple Pay)

    OK.  A thought here.  Maybe this is crazy, but I think my sorted array should contain keys, not values, and I think I should be populating everything from the refunds_by_tender[key] 
        X -The reason is that my UI should be reading from the session state, and my dispatches should be modifying the session state.  It does me no good to interact with the tenders array because that is strictly local.
        -This is cool.  I mean, I'm sure I would have come to this conclusion eventually but I feel like I anticpated it.

    Now, how to handle the loop?
        -For the 70 panel.  Should I have a local state property to control this?  I kind of hope not?  My ideal would be to just have an object that contains the options, and display those options PURELY based on the status of the current index.

        -OK.  Do I want to have a local state?  Let me think about the alternatives.
            -If I don't:
                I think I just have an object for the 70 panel, and I render that 70 panel as: {70_Options[panelStatus]}

            -If I do:
                I dispatch the active panels by hand.  This is more by-hand logic so more opportunities for me to make dumb mistakes.  BUT if I encounter ANY scenario where the 70 panel can't be derived from the index, I think I have to do this anyways?  

    12:50:
        Had lunch, did some house chores, ready to get back to it.  I do have some simple tasks that need to be done, like creating the Cash Back page and the Send Receipt page.  I was actually planning to put these off and try to eat the frog, but I think it might actually be better to do them now.  I will need them no matter what, and it would be helpful to get some cheap wins to build momentum.

    2:20:
        OK. Let's do this.  How to handle the loop, which might not even be a loop.  Ideally, I want this sequence to run without any reference to the tender type.  That will make the logic so much longer.  

        Automatic Logic:
            
            If Active Tender status = Not Started {
                If there's a user choice, dispatch Active2line, else...
                If there's a failure, dispatch Failure, else...
                dispatch Complete
            }

            If ActiveTender status = Active2line {
                display UserChoice 70 panel
            }

            If ActiveTender status = Failure {
                display Failure 70 panel
            }

            If ActiveTender status = Complete or Swapped {
                dispatch Increment counter
            }

    Stepping out of the details for a moment.  I feel like this is where a better logician would be able to breeze through.  I have this sense that there's some really clean abstraction out there for this problem but I am having trouble finding it :/

        -OK, here's an idea.  What if every tender item contains a UI property, even Cash and Store Credit?  The 70 panel just displays whatever is the current UI property of the active item, and that can be altered by dispatching to the refunds_by_tender state, mostly through other UIs?  

        -This feel like the way, although I'm not sure exactly how to do it.  


    The other way to do it:
        -I could have a property in each LI that contains a sort of Primary Key status, and from that the 70 panel could be derived, but that seems like just a more abstracted version of the previous solution, and also less flexible if I have to change something, which I very likely will.

        OK, so how to do this?
            -I'm definitely going to need an object with an interface for all possible states.
            -I might want an object just with the state names?  They will be used in:
                -the Tenderizer, because each refund tender needs one to start.
                -Finalize Refund
                    OK, so not actually that many.  Can probably skip.
            -Ideally each state is abstracted as much as possible.  
                -For instance, the Failure Screens and the User Choice screens are so similar that it would really be a shame to make a bunch of copies by hand.
            -If I do that, I will need either some logic to derive the states from limited information, or more properties in the Tenderizer.  

        I think I might just need to dive in here.  If what I'm about to do is a rebus stage then I'm not confident I can abstract my way past, and if there isn't then I'm just wasting time.  

            I think I can actually abstract this down to 2 screens, one of which I already have.

        Now got another concern which is itching at me, and that is if the two of these should be separate components.  I think the answer is No, because in terms of both reading and writing to the state it's kind of helpful to have them all at hand.  But it still feel like A Lot Of JSX All At Once.  IDK.  If someone challenged me I could make the case for why it's all together.  None of this is reused anywhere.  

    5:00
        Got another concern / itch.  I feel like the options I'm going to display are the product of the tender's Type and Status and I feel like there's got to be a systematic way to derive them.

            -Intuition is sort of:  Type behavior changes a lot more than Status.  So I think that means more of my inputs should live on the Type (so I should put it in the tenderizer? )

        It's a question of what should live where.  OK.  Since I am already doing Type-dependent assignment in the Tenderizer, maybe that's the place?  

    5:45
        Copied from the TR:
        -OK.  Breakthrough.  I had two key insights: First, that behaviors based on tender Type vary a lot more than behaviors based on tender Status, which means ... something important?  
            -Do my definitions in Type and my logic in status?
            -Easier define how Status responds to Type than vice versa?
            -Easier to hold status constant and vary types?  
            -Arguments live in Type, functions live in Status?  
            -I actually still have yet to find a great explanation the pattern to the pattern, but it means I'm defining almost all behavior specifics in Type. 
        The other breakthrough is that I'm already doing some Type-based definition in the Tenderizer function, so that is the natural place to handle all of the Type-specific defining.  I had type-specific logic in three places and that was itching, although at the time I didn't realize why.

    6:15
        Should I be defining button behavior in here?  Like, get it ALL in the Tenderizer?  Not sure.

        -I've also noticed that I'm kind of losing speed.  For some reason this feels like a decent stopping point, like I should let that decision mellow for a bit.

        However, I still feel pretty motivated, so I'm thinking about switching to something easy, like maybe the Icons.  I feel like that's something I'll definitely need at some point, and it shouldn't be too hard for me to just pump out with some music on.  Let's see how we do!

        If I REALLY want to go to OT I could finish up the Select Receipt screen, but that thing is so unimportant that I'm probably better off just stopping.

    6:50:
        I think I'm done for the day.  Can't swallk, but siit definitely earned.  Gonna ponder takeways for notes-tr and record after.
    

5 Feb 2023
    -9:55:
        Found myself looking up the SR-71 and realize I need to work.  I think my first move is actually going to be working on that tender icon component.  I do need it and it would be a nice, satisfying way to get into the work.  

        -After that: I need to think about how to arrange the button/dispatch logic in FinalizeRefund and where it should live.  I am really, really close to turning the corner on this final boss.  

    -Not related to anything in the current workstream, but I am kind of liking having an object with the shared names.  It's already kind of convenient for consistency, and I just realized there's another benefit, too.  If I have something used in a lot of places (like tenderTypes) and I need to do something different, like adding an ApplePay tender, having it as a single reference object lets me find EVERY place where I might need to incorporate the new thing.

    12:20:
        TenderBadges took longer than I was expecting and the icons will need to be replaced because they are inconsistent and look like ass, but I'm ready to move ahead.  The first thing I should do is to set a 10-minute timer to eat all the food at my desk or else I'm gonna crash later. And no time wasters or this break will turn into 110 minutes :/

    12:30:
        Back at it.  OK, time for the main event today: to get all this working.  What do I need to resolve?

            -I think this is where I'm getting hung up: AFAICT the UI in the 70 panel can be determined by Type or by Status.  
                -User Choice: Type
                -Failure Choice: Status
                -Confirm Cash: Status (I think the only time the progress2line status appears is when you are confirming cash?)
                -Refund SC: Type
                -Refund Cash: Type

            -And AFAICT, a type that's in the queue should never actually change.  
        
            -I THINK that the model is:

                -Status determines what screen to display
                -Type determines how to populate it? And populating includes 'What your status becomes when you click this button'
                
        So, for a Debit card: 
                    -In Progress:  70 = UserChoice
                        If they choose Debit:
                    -Failure: 70 = Failure Choice
                    -Success: 70 = 
                        If they choose Cash: 
                    -progress2Line = Confirm Cash:

        -One choice is becoming clear.  I think the logic and state-setting needs to live in the FinalizeRefund section, although it should definitely be reading a lot of props from the objects.
            -First, I would generally expect to find 'Logic to determine what this component shows' in the component itself, especially if that logic isn't shared.
            -Second, the logic affects the local state in FinalizeRefund and setting that local state anywhere else just makes less sense.

        -OK, pause.  I'm getting an error about a 'dataName' prop and if I add more shit it will just be harder to find later.  
            -I don't get the error on the Returns homepage, so I don't think it's related to that reportWebVitals I deleted earlier.
            -So let's take stuff out of the file and see where it resolves.
                -It does.
            -As long as I am not rendering the Check icon, it seems OK.  
            -I tried hand-inputting the props and got the same error, so I think it's just a bad component?  Still sucks because that one was hard to find.  Well, let's see if an alternative solves it?
            -Used a different icon and it's OK now.  Still looks like ass.

    2:25
        Debugged and re-grocered.  I think I just gotta try writing this logic so I can get something to refer to.  I am leaning more towards putting the different screens in components, but is that good?  

        -I've said this before but I think the logic should JUST set the state?  I also think the point of this logic is JUST to get the user to the point where they make a choice.  

        What even handlers do I need, and how am I going to assign them?
            -In Kind: refund to original tender?  Or does this happen unless they choose something else?
            -Cash: change global status, 

        -OK, a thought.  I think I might need to have an object of Status.  All the Types will be in standard formats so they are easy to plug into the Status Object, but the Status Object is the intermediary between the State and the UI.  

        -It's either that or I include everything status-related in the Tenderizer?  Like a   [type].[status].property   kind of deal?  

    4:40:
        -Looks like I've run face-first into a wall.  From what I understand: I don't think I can set the Returns state until rendering of the child (FinalizeRefund) is complete.  

        OK, that makes sense.  I did have the feeling that this code was kind of sketch.  My options are:
            -Handle the initial state-setting with useEffect()

            -Figure out some way to calculate Status before it gets to FinalizeRefund.  

    -I think useEffect() is the easy way out.  My sense is that unless I am handling asnychronous operations, wanting to useEffect() is sort of a yellow flag that I should be looing for a better way to code it.  So I should cross-examine this argument.

        + I need to evaulate the queue tenders sequentially, starting with the top.  Until I sort the tenders in FinalizeRefund, I don't even know what that order is or which is first.
            - We need them as an object in the MatchMaker, but AFAICT after that all we need is the array.  Why not sort the object in the Matchmaker and just have that be the state?  Or, maybe just do the whole thing as an array and skip the object phase entirely?
                + Logic is more complex (or at least not as fast) 
                    -For the scale we're working on, speed is basically meaningless.
                + It also feels kind of hacky. We're performing operations based on primary keys.  Objects just seem like a natural fit.

        + Well, OK, then what?  We still have to process them sequentially.
            -Suppose we've got 

        + You said earlier speed probably doesn't matter at this scale.  Well, what are a few extra re-renders to us?  

    5:50
        OK, screw all this.  I'm just going to try it as a useEffect.  There isn't a clearly-better solution apparent to me and this gets me moving again.

        Got it working, although getting a warning message that I can disable by clicking the lightbulb.  I think I'm done for the night.  I'm pretty worn out right now.

10 Feb 2023
    2:50
    I think I have done enough that I can safely claim to have 'worked' today if anyone asks me.
        
    X -First, I want to try running the effect on every re-load and see what happens.  
        -This works.  However, I did notice a LOT of extra cycles.  Looked like maybe 3 cycles per list item?  

    X -Then, I think I should do a ride-along with this code.  Just follow through it step by step because I don't actually know what's happening.

    -Then I want to do some thinking and see if there's a better way to handle this.

    Man.  This itches.  This itches and I am stalling here.  OK, stream of consciousness: 
        -in my experience, useEffect usually means I should be doing something different.  I feel like there's got to be an easier way to handle this.  
        - OK. If I KNEW that the correct answer didn't use useEffect, what would I guess next?
        
            -IF I had to, my activeTenderSort() function would probably be a good place.  But this does not and cannot dispatch, and I need to dispatch.

        -If there's an easier way, it's not coming to mind.  And where that brings me back to is something like the traffic cop scenario in UseEffect that I'm looking at now.  SOMETHING needs to:
            - check the next Not Started item in the queue
            - Resolve + increment if possible
            - If not, figure out what user input is required and set to that state.

    -OK.  Where do I keep getting looped out?  I don't understand why my ActiveIndex is 1.  It should be zero or 2, right?  
        -Well, I found one small bug that was having a big effect.  When using a number in a variable for assigning the value of a new variable, ++ !== + 1.  Oops.  Now, I'm looping through the WHOLE array, but that's good, right?  My Failure cases and my User Input cases don't actually have the status the Traffic Cop is checking for, so this should just buzz through them all?

    5:20: Gonna swalk (finally!) To start tomorrow:
        * copied to tomorrow's work *

22 Feb 2023
    11:10
    Yes, late start, but other than ~20 minutes of time-wasting I was doing chores and girl-proofing the house so I don't feel bad.  

    -Computing the display text (credit card ****1234, etc.) would be a nice little starter project.
        -I think this can actually be smaller than I expected.  AFAICT all the account numbers can be obscured in the same way.  Just **** plus the last 4 of the string.
            -At some point I could make it more sophisticated and get the card issuer from the number but I don't need it for demos.  Rule 1.
            -OK.  I have labels in there.  Is this stupid?  Or, more specifically, is this a case for "Leave it and move on?"
            -I'm thinking yes?  The person I want to be would leave it and move on.  I'm gonna be like him.
    X - All the tender types need corresponding labels.  Right now they are all hard-coded to Not Started.

    -OK.  I think the 70 panel is the next big ogre we have to slay.  I vaguely have the sense that I'll be using an object and keys, but this isn't actually finalized.  
        -First, going to look back through the record and see what I already have.  
        -This wasn't really resolved.  The model I have in my mind is:
            -Status determines the 70 panel.
            -Type determines the contents of the 70 panel.
        -For this approach to work, there needs to be a 1:1 relationship between status and 70 panel.  So I think it goes like: Type determines the possible Statuses you can change to.
        -Is there a 1:1 relationship?  IF NOT: I can either figure out a way to derive the 70 panel from both Type and Status (but then what will I use for my key if I'm displaying the 70 panel from the key?) or in a pinch I could just create more Statuses.  I think the second one might be better.  After all, nothing says that the UI of a different status has to appear different.  Like if somehow a Debit Card and a Check CANNOT share the same 2-line, I could make a debit2Line status and check2Line status but use the same icons, text, etc. 

        -I guess I should list statuses and see if ALL the Types can use the same 70 panel.

            .notStarted {
                all:           NA
            }

            .inProgress {
                credit:         NA
                check:          UserChoice
                debit:          UserChoice
                storeCredit:    SwipeCard
                cash:           Close Register
            }

            .progress2Line {

                // AFACIT, only Debit and Check could ever get here, and only if they decline In-Kind payment. So: 

                credit:         /
                check:          /
                debit:          Confirm Cash
                storeCredit:    Confirm Cash
                cash:           /
            }

            .failure {
                credit:         SC or Cash
                check:          SC or Cash
                debit:          SC or Cash
                storeCredit:    NA?
                cash:           NA
            }

            .failureCash{

            }

            .complete {                
                All:            NA

            .swapped {
                All:            NA
            }
        
        So from this list, the only time we need a 70-panel at all is if we are asking the user to make some choice:
            -Choosing In-Kind or Cash for Check or Debit
            -Choosing Cash or Store Credit for the Failures
            -Confirmation of completed action for SC or Cash.
        
        Another thought:
            -I think The Failures are going to need an additional state, a failureCash state, where the associate has selected Cash and is confirming it.

        So then, here's where I think we go with this.  In the FinalizeRefund file, I make a  paths70{} object.  For each status that requires user input, I define a route.  If there's no variablity, it's just a path to the 70 panel.  Where there is variablity, it's activeItem[type].status, and the specifics live on the refund according to type?  

        OK.  I think that's the route.  It feels like the missing piece. I feel good about it.  And when I swalk today I need to do some hard thinking about how I didn't figure this out sooner.  Like, it might be worthwhile to do a workout tomorrow morning and then spend the afternoon analyzing this.

        What to do with the 70 panels?  What do I definitely need?

            X -A Warning component (configurable to userChoice)
            X -A ConfirmCash component
            X -A SwipeCard component (If too hard to configure ConfirmCash)
        
        -I think it will be easier to have each one be a full 70 panel, since some of them are going to depent on buttons.
        X -I also think I'm just going to bite the bullet and just make them all separate components.  That should be a lot more readable.  Doing that should get me into a good groove.  Let's go.

    4:10
        I've got the three 70 panels I need.  Things I need that I don't have:
            -a Paths70 object that tells what 70-panel to display based on Type and Status
            -a universal format for UserInput70 so that no matter what's populating it, all variable fields are getting what they need.
                -Ideally, this won't need its own internal object pathing although that might be too much to ask for?
                    -I'm now wondering if this was a mistake for the Payouts?  Like, I could technically have all of this live in the Tenderizer?  
                    -I'm kind of doing conditional logic though objects.  Is this a good thing to do?
                -Ideally, all relevant info lives in a single place although again, maybe too much to ask for?  
            -Any information that's going to live in the Tenderizer needs to be populated there.  
                -Maybe I should be applying my lowest-level heuristic here.  If information is consumed in more than one place (like the displayPrice or the Status) it's assigned in the Tenderizer, but otherwise it just lives in the same place it's consumed.  
                    -So actually I think what I did with Payouts70 is correct.  I don't need those text strings anywhere else.
            -I need to figure out how I'm going to handle the Dispatch functions and where is the best place for them to live.
        
        I think I should do the first two in order because that will give me something to look at.

        However, since my velocity is not amazing and I'll need some time to get the smoke-taste off my tongue I think I might have a swalk now.

    5:30.
    -Got another choice to make.  I was originally planning to have per-state pathing live on the tenders as: 
    [tenderType].[status] ) 
    but now I'm considering reversing it. In FinalizeRefund I would route as:
    [status].[tenderType]  
    
    My reasons are:
        -AFAICT I'm not consuming type/status-specific information anywhere else, so putting that information in the refunds_by_tender violates the Lowest-Shared principle.
        -It should let me do my populating extra prop-drilling since I can populate directly into the components I'm using
        -I think it makes it easier for me to define and consume all of my dispatch functions in the FinalizeRefund component.

    6:20:
    I think I'm gonna call it for the day.  I'm sure I will have to do a bunch of detailed fuckery to get this working, but I finally think I've got a clear conceptual model.  What did I figure out today?
        
        -I knew the Lowest-Shared principle but I didn't actually grok how to apply it to this problem until today.  Now I have a good idea of what should live where.

        -No, seriously: I think that tiny little revelation of using the ?? Nullish Coalescing Operator to apply Type-specific conditions where necessary and Status-specify conditions otherwise was what really broke me through.  Looking back, the fact that the 70 panel could be determined by either was what was slowing me down.  

        Also, it's funny.  When I went for my swalk, my sentiment was "Whatever pattern I identify, it seems like it should be repeatable on an infinite number of levels, not just two.  Well, this is a pattern I could use infinitely.  
        For n levels of nested conditions:
            active = [Most Specific] ?? [...] ?? [Least Specific]

        Of course, that does leave me the task of sorting like conditions together, but I think that's more doable.  I need a heuristic for how to decide which parents go to which children.  That pattern should work in any order, but some orders are probably a lot better than others.
            -I think it has something to do with shared values.  Like, if I were to do it in reverse order: [tenderType].[status], I would have been writing tType.xxx.failure   A LOT.  

        -I don't know if it's actually good, but something about the object-path pattern seems very clean to me.  

        -I'm also not sure I understood that I was solving a problem at the time, but having more Status options helped a lot.  If I didn't have that I would have to conditionally alter the statuses, and that sounds pretty hard.

        -Looking at this, it's kind of underwhelming.  I wish I could compare the understanding from this morning to the understanding from tonight to see what changed.  





